import {
  ANIMATION_DURATION_MS,
  ANIMATION_TIMING_FUNCTION,
  ChartProvider,
  ChartsLocalizationProvider,
  ChartsSurface,
  ChartsText,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  batchMeasureStrings,
  clampAngle,
  createSelector,
  createSelectorMemoizedWithOptions,
  deg2rad,
  generateSvg2rotation,
  getAxisIndex,
  getBarDimensions,
  getColor_default,
  getLabel,
  getSVGPoint,
  getStringSize,
  getValueToPositionMapper,
  isCartesianSeries,
  isCartesianSeriesType,
  isDateData,
  isDeepEqual,
  isOrdinalScale,
  isPolarSeriesType,
  number_default,
  selectorBrushShouldPreventTooltip,
  selectorChartAxisZoomData,
  selectorChartPolarCenter,
  selectorChartPropsHeight,
  selectorChartPropsWidth,
  selectorChartRawRotationAxis,
  selectorChartRawXAxis,
  selectorChartRotationAxis,
  selectorChartSeriesConfig,
  selectorChartSeriesEmptyFlatbushMap,
  selectorChartSeriesFlatbushMap,
  selectorChartSeriesProcessed,
  selectorChartXAxis,
  selectorChartYAxis,
  selectorChartZoomIsInteracting,
  selectorChartsFocusedItem,
  selectorChartsHighlightXAxisValue,
  selectorChartsHighlightYAxisValue,
  selectorChartsInteractionAxisTooltip,
  selectorChartsInteractionPointerX,
  selectorChartsInteractionPointerY,
  selectorChartsInteractionTooltipXAxes,
  selectorChartsInteractionTooltipYAxes,
  selectorChartsItemIsFocused,
  selectorChartsLastInteraction,
  selectorChartsTooltipItem,
  selectorChartsTooltipItemIsDefined,
  selectorChartsTooltipItemPosition,
  useAnimate,
  useAnimateBar,
  useAnimateBarLabel,
  useBarSeriesContext,
  useChartBrush,
  useChartCartesianAxis,
  useChartContext,
  useChartGradientIdObjectBoundBuilder,
  useChartHighlight,
  useChartId,
  useChartInteraction,
  useChartKeyboardNavigation,
  useChartRootRef,
  useChartTooltip,
  useChartZAxis,
  useChartsLocalization,
  useDrawingArea,
  useIsHydrated,
  useItemHighlighted,
  useLegend,
  useRotationAxes,
  useRotationAxis,
  useSeries,
  useSkipAnimation,
  useStore,
  useSvgRef,
  useXAxes,
  useXAxis,
  useYAxes,
  useYAxis,
  useZAxes,
  warnOnce
} from "./chunk-MAUWBMSJ.js";
import {
  useThemeProps
} from "./chunk-ZXHLZ5RU.js";
import {
  getReactElementRef
} from "./chunk-6DGARLML.js";
import {
  Button_default
} from "./chunk-G66SEGLY.js";
import {
  IconButton_default
} from "./chunk-WXCOQNT7.js";
import {
  appendOwnerState_default,
  mergeSlotProps_default,
  resolveComponentProps_default
} from "./chunk-FO3JKVOD.js";
import {
  refType_default
} from "./chunk-NJQXWWX2.js";
import {
  createSimplePaletteValueFilter
} from "./chunk-ZCSSBJ3Q.js";
import "./chunk-GNM62ZLU.js";
import "./chunk-7P7CD666.js";
import {
  chainPropTypes
} from "./chunk-ITGWAFDM.js";
import {
  _objectWithoutPropertiesLoose,
  useLazyRef
} from "./chunk-H5UWRAXJ.js";
import {
  require_react_dom
} from "./chunk-YF4B4G2L.js";
import {
  setRef
} from "./chunk-RHS5773M.js";
import "./chunk-5LRLXIE7.js";
import "./chunk-ZOJLJBKP.js";
import {
  capitalize_default,
  internal_createExtendSxProp,
  memoTheme_default,
  useDefaultProps
} from "./chunk-XFELE4RA.js";
import {
  ownerDocument,
  useEventCallback_default
} from "./chunk-76X5W7E2.js";
import {
  useForkRef
} from "./chunk-ABUGKEBG.js";
import {
  _extends,
  clsx_default,
  composeClasses,
  exactProp,
  generateUtilityClass,
  generateUtilityClasses,
  identifier_default,
  require_prop_types,
  resolveProps,
  shouldForwardProp,
  styled_default,
  unstable_createUseMediaQuery,
  useEnhancedEffect_default,
  useId,
  useRtl,
  useTheme
} from "./chunk-AW4WS44S.js";
import {
  require_jsx_runtime
} from "./chunk-2YVA4HRZ.js";
import {
  require_react
} from "./chunk-WUR7D6NS.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
var React52 = __toESM(require_react(), 1);
var import_prop_types30 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
var React8 = __toESM(require_react(), 1);
var import_prop_types4 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/barElementClasses.js
function getBarElementUtilityClass(slot) {
  return generateUtilityClass("MuiBarElement", slot);
}
var barElementClasses = generateUtilityClasses("MuiBarElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    id,
    isHighlighted,
    isFaded
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getBarElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
var React3 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/useSlotProps/useSlotProps.js
function useSlotProps(parameters) {
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps_default(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps_default({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.additionalProps?.ref);
  const props = appendOwnerState_default(elementType, {
    ...mergedProps,
    ref
  }, ownerState);
  return props;
}
var useSlotProps_default = useSlotProps;

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var React = __toESM(require_react(), 1);
function onPointerDown(event) {
  if ("hasPointerCapture" in event.currentTarget && event.currentTarget.hasPointerCapture(event.pointerId)) {
    event.currentTarget.releasePointerCapture(event.pointerId);
  }
}
var useInteractionItemProps = (data, skip) => {
  const {
    instance
  } = useChartContext();
  const interactionActive = React.useRef(false);
  const onPointerEnter = useEventCallback_default(() => {
    interactionActive.current = true;
    instance.setLastUpdateSource("pointer");
    instance.setTooltipItem(data);
    instance.setHighlight(
      // @ts-ignore
      data.type === "sankey" ? data : {
        seriesId: data.seriesId,
        dataIndex: data.dataIndex
      }
    );
  });
  const onPointerLeave = useEventCallback_default(() => {
    interactionActive.current = false;
    instance.removeTooltipItem(data);
    instance.clearHighlight();
  });
  React.useEffect(() => {
    return () => {
      if (interactionActive.current) {
        onPointerLeave();
      }
    };
  }, [onPointerLeave]);
  return React.useMemo(() => skip ? {} : {
    onPointerEnter,
    onPointerLeave,
    onPointerDown
  }, [skip, onPointerEnter, onPointerLeave]);
};

// node_modules/@mui/x-charts/esm/BarChart/AnimatedBarElement.js
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var _excluded = ["ownerState", "skipAnimation", "id", "dataIndex", "xOrigin", "yOrigin"];
function AnimatedBarElement(props) {
  const {
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const animatedProps = useAnimateBar(props);
  return (0, import_jsx_runtime.jsx)("rect", _extends({}, other, {
    filter: ownerState.isHighlighted ? "brightness(120%)" : void 0,
    opacity: ownerState.isFaded ? 0.3 : 1,
    "data-highlighted": ownerState.isHighlighted || void 0,
    "data-faded": ownerState.isFaded || void 0
  }, animatedProps));
}

// node_modules/@mui/x-charts/esm/hooks/useIsItemFocused.js
function useIsItemFocused(item) {
  const store = useStore();
  return store.use(selectorChartsItemIsFocused, item);
}

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick", "skipAnimation", "layout", "x", "xOrigin", "y", "yOrigin", "width", "height"];
function BarElement(props) {
  const {
    id,
    dataIndex,
    classes: innerClasses,
    color,
    slots,
    slotProps,
    style,
    onClick,
    skipAnimation,
    layout,
    x,
    xOrigin,
    y,
    yOrigin,
    width,
    height
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const itemIdentifier = React3.useMemo(() => ({
    type: "bar",
    seriesId: id,
    dataIndex
  }), [id, dataIndex]);
  const interactionProps = useInteractionItemProps(itemIdentifier);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted(itemIdentifier);
  const isFocused = useIsItemFocused(React3.useMemo(() => ({
    type: "bar",
    seriesId: id,
    dataIndex
  }), [id, dataIndex]));
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color,
    isFaded,
    isHighlighted,
    isFocused
  };
  const classes = useUtilityClasses(ownerState);
  const Bar = slots?.bar ?? AnimatedBarElement;
  const barProps = useSlotProps_default({
    elementType: Bar,
    externalSlotProps: slotProps?.bar,
    externalForwardedProps: other,
    additionalProps: _extends({}, interactionProps, {
      id,
      dataIndex,
      color,
      x,
      xOrigin,
      y,
      yOrigin,
      width,
      height,
      style,
      onClick,
      cursor: onClick ? "pointer" : "unset",
      stroke: "none",
      fill: color,
      skipAnimation,
      layout
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime2.jsx)(Bar, _extends({}, barProps));
}
true ? BarElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types.default.object,
  dataIndex: import_prop_types.default.number.isRequired,
  id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
  layout: import_prop_types.default.oneOf(["horizontal", "vertical"]).isRequired,
  skipAnimation: import_prop_types.default.bool.isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types.default.object,
  xOrigin: import_prop_types.default.number.isRequired,
  yOrigin: import_prop_types.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function barClipPathPropsInterpolator(from, to) {
  const interpolateX = number_default(from.x, to.x);
  const interpolateY = number_default(from.y, to.y);
  const interpolateWidth = number_default(from.width, to.width);
  const interpolateHeight = number_default(from.height, to.height);
  const interpolateBorderRadius = number_default(from.borderRadius, to.borderRadius);
  return (t) => {
    return {
      x: interpolateX(t),
      y: interpolateY(t),
      width: interpolateWidth(t),
      height: interpolateHeight(t),
      borderRadius: interpolateBorderRadius(t)
    };
  };
}
function useAnimateBarClipPath(props) {
  const initialProps = {
    x: props.layout === "vertical" ? props.x : props.xOrigin,
    y: props.layout === "vertical" ? props.yOrigin : props.y,
    width: props.layout === "vertical" ? props.width : 0,
    height: props.layout === "vertical" ? 0 : props.height,
    borderRadius: props.borderRadius
  };
  return useAnimate({
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height,
    borderRadius: props.borderRadius
  }, {
    createInterpolator: barClipPathPropsInterpolator,
    transformProps: (p) => ({
      d: generateClipPath(props.hasNegative, props.hasPositive, props.layout, p.x, p.y, p.width, p.height, props.xOrigin, props.yOrigin, p.borderRadius)
    }),
    applyProps(element, {
      d
    }) {
      if (d) {
        element.setAttribute("d", d);
      }
    },
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}
function BarClipPath(props) {
  const {
    maskId,
    x,
    y,
    width,
    height,
    skipAnimation
  } = props;
  const {
    ref,
    d
  } = useAnimateBarClipPath({
    layout: props.layout ?? "vertical",
    hasNegative: props.hasNegative,
    hasPositive: props.hasPositive,
    xOrigin: props.xOrigin,
    yOrigin: props.yOrigin,
    x,
    y,
    width,
    height,
    borderRadius: props.borderRadius ?? 0,
    skipAnimation
  });
  if (!props.borderRadius || props.borderRadius <= 0) {
    return null;
  }
  return (0, import_jsx_runtime3.jsx)("clipPath", {
    id: maskId,
    children: (0, import_jsx_runtime3.jsx)("path", {
      ref,
      d
    })
  });
}
function generateClipPath(hasNegative, hasPositive, layout, x, y, width, height, xOrigin, yOrigin, borderRadius) {
  if (layout === "vertical") {
    if (hasPositive && hasNegative) {
      const bR2 = Math.min(borderRadius, width / 2, height / 2);
      return `M${x},${y + height / 2} v${-(height / 2 - bR2)} a${bR2},${bR2} 0 0 1 ${bR2},${-bR2} h${width - bR2 * 2} a${bR2},${bR2} 0 0 1 ${bR2},${bR2} v${height - 2 * bR2} a${bR2},${bR2} 0 0 1 ${-bR2},${bR2} h${-(width - bR2 * 2)} a${bR2},${bR2} 0 0 1 ${-bR2},${-bR2} v${-(height / 2 - bR2)}`;
    }
    const bR = Math.min(borderRadius, width / 2);
    if (hasPositive) {
      return `M${x},${Math.max(yOrigin, y + bR)} v${Math.min(0, -(yOrigin - y - bR))} a${bR},${bR} 0 0 1 ${bR},${-bR} h${width - bR * 2} a${bR},${bR} 0 0 1 ${bR},${bR} v${Math.max(0, yOrigin - y - bR)} Z`;
    }
    if (hasNegative) {
      return `M${x},${Math.min(yOrigin, y + height - bR)} v${Math.max(0, height - bR)} a${bR},${bR} 0 0 0 ${bR},${bR} h${width - bR * 2} a${bR},${bR} 0 0 0 ${bR},${-bR} v${-Math.max(0, height - bR)} Z`;
    }
  }
  if (layout === "horizontal") {
    if (hasPositive && hasNegative) {
      const bR2 = Math.min(borderRadius, width / 2, height / 2);
      return `M${x + width / 2},${y} h${width / 2 - bR2} a${bR2},${bR2} 0 0 1 ${bR2},${bR2} v${height - bR2 * 2} a${bR2},${bR2} 0 0 1 ${-bR2},${bR2} h${-(width - 2 * bR2)} a${bR2},${bR2} 0 0 1 ${-bR2},${-bR2} v${-(height - bR2 * 2)} a${bR2},${bR2} 0 0 1 ${bR2},${-bR2} h${width / 2 - bR2}`;
    }
    const bR = Math.min(borderRadius, height / 2);
    if (hasPositive) {
      return `M${Math.min(xOrigin, x - bR)},${y} h${width} a${bR},${bR} 0 0 1 ${bR},${bR} v${height - bR * 2} a${bR},${bR} 0 0 1 ${-bR},${bR} h${-width} Z`;
    }
    if (hasNegative) {
      return `M${Math.max(xOrigin, x + width + bR)},${y} h${-width} a${bR},${bR} 0 0 0 ${-bR},${bR} v${height - bR * 2} a${bR},${bR} 0 0 0 ${bR},${bR} h${width} Z`;
    }
  }
  return void 0;
}

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
var React7 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
var React6 = __toESM(require_react(), 1);
var import_prop_types3 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/barLabelClasses.js
function getBarLabelUtilityClass(slot) {
  return generateUtilityClass("MuiBarLabel", slot);
}
var barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded", "animate"]);
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded", !skipAnimation && "animate"]
  };
  return composeClasses(slots, getBarLabelUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/getBarLabel.js
function getBarLabel(options) {
  const {
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  } = options;
  if (barLabel === "value") {
    return value ? value?.toString() : null;
  }
  return barLabel({
    seriesId,
    dataIndex,
    value
  }, {
    bar: {
      height,
      width
    }
  });
}

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabel.js
var React5 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var _excluded3 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes", "skipAnimation", "layout", "xOrigin", "yOrigin", "placement"];
var BarLabelComponent = styled_default("text", {
  name: "MuiBarLabel",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${barLabelClasses.faded}`]: styles.faded
  }, {
    [`&.${barLabelClasses.highlighted}`]: styles.highlighted
  }, styles.root]
})(({
  theme
}) => _extends({}, theme?.typography?.body2, {
  stroke: "none",
  fill: (theme.vars || theme)?.palette?.text?.primary,
  transitionProperty: "opacity, fill",
  transitionDuration: `${ANIMATION_DURATION_MS}ms`,
  transitionTimingFunction: ANIMATION_TIMING_FUNCTION,
  pointerEvents: "none"
}));
function BarLabel(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarLabel"
  });
  const {
    isFaded
  } = props, otherProps = _objectWithoutPropertiesLoose(props, _excluded3);
  const animatedProps = useAnimateBarLabel(props);
  const textAnchor = getTextAnchor(props);
  const dominantBaseline = getDominantBaseline(props);
  const fadedOpacity = isFaded ? 0.3 : 1;
  return (0, import_jsx_runtime4.jsx)(BarLabelComponent, _extends({
    textAnchor,
    dominantBaseline,
    opacity: fadedOpacity
  }, otherProps, animatedProps));
}
function getTextAnchor({
  placement,
  layout,
  xOrigin,
  x
}) {
  if (placement === "outside") {
    if (layout === "horizontal") {
      return x < xOrigin ? "end" : "start";
    }
    return "middle";
  }
  return "middle";
}
function getDominantBaseline({
  placement,
  layout,
  yOrigin,
  y
}) {
  if (placement === "outside") {
    if (layout === "horizontal") {
      return "central";
    }
    return y < yOrigin ? "auto" : "hanging";
  }
  return "central";
}
true ? BarLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types2.default.object,
  dataIndex: import_prop_types2.default.number.isRequired,
  /**
   * Height of the bar this label belongs to.
   */
  height: import_prop_types2.default.number.isRequired,
  isFaded: import_prop_types2.default.bool.isRequired,
  isHighlighted: import_prop_types2.default.bool.isRequired,
  layout: import_prop_types2.default.oneOf(["horizontal", "vertical"]).isRequired,
  /**
   * The placement of the bar label.
   * It controls whether the label is rendered in the center or outside the bar.
   * @default 'center'
   */
  placement: import_prop_types2.default.oneOf(["center", "outside"]),
  seriesId: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]).isRequired,
  skipAnimation: import_prop_types2.default.bool.isRequired,
  /**
   * Width of the bar this label belongs to.
   */
  width: import_prop_types2.default.number.isRequired,
  /**
   * Position in the x-axis of the bar this label belongs to.
   */
  x: import_prop_types2.default.number.isRequired,
  /**
   * The x-coordinate of the stack this bar label belongs to.
   */
  xOrigin: import_prop_types2.default.number.isRequired,
  /**
   * Position in the y-axis of the bar this label belongs to.
   */
  y: import_prop_types2.default.number.isRequired,
  /**
   * The y-coordinate of the stack this bar label belongs to.
   */
  yOrigin: import_prop_types2.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var _excluded4 = ["seriesId", "classes", "color", "dataIndex", "barLabel", "slots", "slotProps", "xOrigin", "yOrigin", "x", "y", "width", "height", "value", "skipAnimation", "layout", "barLabelPlacement"];
var _excluded22 = ["ownerState"];
function BarLabelItem(props) {
  const {
    seriesId,
    classes: innerClasses,
    color,
    dataIndex,
    barLabel,
    slots,
    slotProps,
    xOrigin,
    yOrigin,
    x,
    y,
    width,
    height,
    value,
    skipAnimation,
    layout,
    barLabelPlacement
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    classes: innerClasses,
    color,
    isFaded,
    isHighlighted,
    dataIndex,
    skipAnimation,
    layout
  };
  const classes = useUtilityClasses2(ownerState);
  const Component = slots?.barLabel ?? BarLabel;
  const _useSlotProps = useSlotProps_default({
    elementType: Component,
    externalSlotProps: slotProps?.barLabel,
    additionalProps: _extends({}, other, {
      xOrigin,
      yOrigin,
      x,
      y,
      width,
      height,
      placement: barLabelPlacement,
      className: classes.root
    }),
    ownerState
  }), {
    ownerState: barLabelOwnerState
  } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  if (!barLabel) {
    return null;
  }
  const formattedLabelText = getBarLabel({
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  });
  if (!formattedLabelText) {
    return null;
  }
  return (0, import_jsx_runtime5.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
    children: formattedLabelText
  }));
}
true ? BarLabelItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["value"]), import_prop_types3.default.func]),
  classes: import_prop_types3.default.object,
  color: import_prop_types3.default.string.isRequired,
  dataIndex: import_prop_types3.default.number.isRequired,
  /**
   * The height of the bar.
   */
  height: import_prop_types3.default.number.isRequired,
  seriesId: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  /**
   * The value of the data point.
   */
  value: import_prop_types3.default.number,
  /**
   * The width of the bar.
   */
  width: import_prop_types3.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var _excluded5 = ["processedSeries", "className", "skipAnimation"];
function BarLabelPlot(props) {
  const {
    processedSeries,
    className,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    seriesId,
    data,
    layout,
    xOrigin,
    yOrigin
  } = processedSeries;
  const barLabel = processedSeries.barLabel ?? props.barLabel;
  if (!barLabel) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)("g", {
    className,
    "data-series": seriesId,
    children: data.map(({
      x,
      y,
      dataIndex,
      color,
      value,
      width,
      height
    }) => (0, import_jsx_runtime6.jsx)(BarLabelItem, _extends({
      seriesId,
      dataIndex,
      value,
      color,
      xOrigin,
      yOrigin,
      x,
      y,
      width,
      height,
      skipAnimation: skipAnimation ?? false,
      layout: layout ?? "vertical"
    }, other, {
      barLabel,
      barLabelPlacement: processedSeries.barLabelPlacement || "center"
    }), dataIndex))
  }, seriesId);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useInternalIsZoomInteracting.js
function useInternalIsZoomInteracting() {
  const store = useStore();
  const isInteracting = store.use(selectorChartZoomIsInteracting);
  return isInteracting;
}

// node_modules/@mui/x-charts/esm/BarChart/checkBarChartScaleErrors.js
var getAxisMessage = (axisDirection, axisId) => {
  const axisName = `${axisDirection}-axis`;
  const axisIdName = `${axisDirection}Axis`;
  const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
};
function checkBarChartScaleErrors(verticalLayout, seriesId, seriesDataLength, xAxisId, xAxis, yAxisId, yAxis) {
  const xAxisConfig = xAxis[xAxisId];
  const yAxisConfig = yAxis[yAxisId];
  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
  const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
  const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
  const discreteAxisDirection = verticalLayout ? "x" : "y";
  const continuousAxisDirection = verticalLayout ? "y" : "x";
  if (discreteAxisConfig.scaleType !== "band") {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
  }
  if (discreteAxisConfig.data === void 0) {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
  }
  if (continuousAxisConfig.scaleType === "band" || continuousAxisConfig.scaleType === "point") {
    throw new Error(`MUI X Charts: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
  }
  if (true) {
    if (discreteAxisConfig.data.length < seriesDataLength) {
      warnOnce([`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} has less data (${discreteAxisConfig.data.length} values) than the bar series of id "${seriesId}" (${seriesDataLength} values).`, "The axis data should have at least the same length than the series using it."], "error");
    }
  }
}

// node_modules/@mui/x-charts/esm/BarChart/useBarPlotData.js
function useBarPlotData(drawingArea, xAxes, yAxes) {
  const seriesData = useBarSeriesContext() ?? {
    series: {},
    stackingGroups: [],
    seriesOrder: []
  };
  const defaultXAxisId = useXAxes().xAxisIds[0];
  const defaultYAxisId = useYAxes().yAxisIds[0];
  const chartId = useChartId();
  const {
    series,
    stackingGroups
  } = seriesData;
  const masks = {};
  const data = stackingGroups.flatMap(({
    ids: seriesIds
  }, groupIndex) => {
    const xMin = drawingArea.left;
    const xMax = drawingArea.left + drawingArea.width;
    const yMin = drawingArea.top;
    const yMax = drawingArea.top + drawingArea.height;
    return seriesIds.map((seriesId) => {
      const xAxisId = series[seriesId].xAxisId ?? defaultXAxisId;
      const yAxisId = series[seriesId].yAxisId ?? defaultYAxisId;
      const layout = series[seriesId].layout;
      const xAxisConfig = xAxes[xAxisId];
      const yAxisConfig = yAxes[yAxisId];
      const verticalLayout = series[seriesId].layout === "vertical";
      const reverse = (verticalLayout ? yAxisConfig.reverse : xAxisConfig.reverse) ?? false;
      checkBarChartScaleErrors(verticalLayout, seriesId, series[seriesId].stackedData.length, xAxisId, xAxes, yAxisId, yAxes);
      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
      const xScale = xAxisConfig.scale;
      const yScale = yAxisConfig.scale;
      const xOrigin = Math.round(xScale(0) ?? 0);
      const yOrigin = Math.round(yScale(0) ?? 0);
      const colorGetter = getColor_default(series[seriesId], xAxes[xAxisId], yAxes[yAxisId]);
      const seriesDataPoints = [];
      for (let dataIndex = 0; dataIndex < baseScaleConfig.data.length; dataIndex += 1) {
        const barDimensions = getBarDimensions({
          verticalLayout,
          xAxisConfig,
          yAxisConfig,
          series: series[seriesId],
          dataIndex,
          numberOfGroups: stackingGroups.length,
          groupIndex
        });
        if (barDimensions == null) {
          continue;
        }
        const stackId = series[seriesId].stack;
        const result = _extends({
          seriesId,
          dataIndex
        }, barDimensions, {
          color: colorGetter(dataIndex),
          value: series[seriesId].data[dataIndex],
          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
        });
        if (result.x > xMax || result.x + result.width < xMin || result.y > yMax || result.y + result.height < yMin) {
          continue;
        }
        if (!masks[result.maskId]) {
          masks[result.maskId] = {
            id: result.maskId,
            width: 0,
            height: 0,
            hasNegative: false,
            hasPositive: false,
            layout,
            xOrigin,
            yOrigin,
            x: 0,
            y: 0
          };
        }
        const mask = masks[result.maskId];
        mask.width = layout === "vertical" ? result.width : mask.width + result.width;
        mask.height = layout === "vertical" ? mask.height + result.height : result.height;
        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
        const value = result.value ?? 0;
        mask.hasNegative = mask.hasNegative || (reverse ? value > 0 : value < 0);
        mask.hasPositive = mask.hasPositive || (reverse ? value < 0 : value > 0);
        seriesDataPoints.push(result);
      }
      return {
        seriesId,
        barLabel: series[seriesId].barLabel,
        barLabelPlacement: series[seriesId].barLabelPlacement,
        data: seriesDataPoints,
        layout,
        xOrigin,
        yOrigin
      };
    });
  });
  return {
    completedData: data,
    masksData: Object.values(masks)
  };
}

// node_modules/@mui/x-charts/esm/BarChart/barClasses.js
function getBarUtilityClass(slot) {
  return generateUtilityClass("MuiBar", slot);
}
var barClasses = generateUtilityClasses("MuiBar", ["root", "series", "seriesLabels"]);
var useUtilityClasses3 = (classes) => {
  const slots = {
    root: ["root"],
    series: ["series"],
    seriesLabels: ["seriesLabels"]
  };
  return composeClasses(slots, getBarUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var _excluded6 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
var BarPlotRoot = styled_default("g", {
  name: "MuiBarPlot",
  slot: "Root"
})({
  [`& .${barElementClasses.root}`]: {
    transitionProperty: "opacity, fill",
    transitionDuration: `${ANIMATION_DURATION_MS}ms`,
    transitionTimingFunction: ANIMATION_TIMING_FUNCTION
  }
});
function BarPlot(props) {
  const {
    skipAnimation: inSkipAnimation,
    onItemClick,
    borderRadius,
    barLabel
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const {
    xAxis: xAxes
  } = useXAxes();
  const {
    yAxis: yAxes
  } = useYAxes();
  const {
    completedData,
    masksData
  } = useBarPlotData(useDrawingArea(), xAxes, yAxes);
  const withoutBorderRadius = !borderRadius || borderRadius <= 0;
  const classes = useUtilityClasses3();
  return (0, import_jsx_runtime7.jsxs)(BarPlotRoot, {
    className: classes.root,
    children: [!withoutBorderRadius && masksData.map(({
      id,
      x,
      y,
      xOrigin,
      yOrigin,
      width,
      height,
      hasPositive,
      hasNegative,
      layout
    }) => {
      return (0, import_jsx_runtime7.jsx)(BarClipPath, {
        maskId: id,
        borderRadius,
        hasNegative,
        hasPositive,
        layout,
        x,
        y,
        xOrigin,
        yOrigin,
        width,
        height,
        skipAnimation: skipAnimation ?? false
      }, id);
    }), completedData.map(({
      seriesId,
      layout,
      xOrigin,
      yOrigin,
      data
    }) => {
      return (0, import_jsx_runtime7.jsx)("g", {
        "data-series": seriesId,
        className: classes.series,
        children: data.map(({
          dataIndex,
          color,
          maskId,
          x,
          y,
          width,
          height
        }) => {
          const barElement = (0, import_jsx_runtime7.jsx)(BarElement, _extends({
            id: seriesId,
            dataIndex,
            color,
            skipAnimation: skipAnimation ?? false,
            layout: layout ?? "vertical",
            x,
            xOrigin,
            y,
            yOrigin,
            width,
            height
          }, other, {
            onClick: onItemClick && ((event) => {
              onItemClick(event, {
                type: "bar",
                seriesId,
                dataIndex
              });
            })
          }), dataIndex);
          if (withoutBorderRadius) {
            return barElement;
          }
          return (0, import_jsx_runtime7.jsx)("g", {
            clipPath: `url(#${maskId})`,
            children: barElement
          }, dataIndex);
        })
      }, seriesId);
    }), completedData.map((processedSeries) => (0, import_jsx_runtime7.jsx)(BarLabelPlot, _extends({
      className: classes.seriesLabels,
      processedSeries,
      skipAnimation,
      barLabel
    }, other), processedSeries.seriesId))]
  });
}
true ? BarPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["value"]), import_prop_types4.default.func]),
  /**
   * The placement of the bar label.
   * It controls whether the label is rendered inside or outside the bar.
   */
  barLabelPlacement: import_prop_types4.default.oneOf(["outside", "inside"]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types4.default.number,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types4.default.func,
  /**
   * If `true`, animations are skipped.
   * @default undefined
   */
  skipAnimation: import_prop_types4.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var React18 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var import_prop_types5 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxisImpl.js
var React14 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsSingleXAxisTicks.js
var React11 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var React9 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/isInfinity.js
function isInfinity(v) {
  return typeof v === "number" && !Number.isFinite(v);
}

// node_modules/@mui/x-charts/esm/utils/timeTicks.js
function yearNumber(from, to) {
  return Math.abs(to.getFullYear() - from.getFullYear());
}
function monthNumber(from, to) {
  return Math.abs(to.getFullYear() * 12 + to.getMonth() - 12 * from.getFullYear() - from.getMonth());
}
function dayNumber(from, to) {
  return Math.abs(to.getTime() - from.getTime()) / (1e3 * 60 * 60 * 24);
}
function hourNumber(from, to) {
  return Math.abs(to.getTime() - from.getTime()) / (1e3 * 60 * 60);
}
var tickFrequencies = {
  years: {
    getTickNumber: yearNumber,
    isTick: (prev, value) => value.getFullYear() !== prev.getFullYear(),
    format: (d) => d.getFullYear().toString()
  },
  quarterly: {
    getTickNumber: (from, to) => Math.floor(monthNumber(from, to) / 3),
    isTick: (prev, value) => value.getMonth() !== prev.getMonth() && value.getMonth() % 3 === 0,
    format: new Intl.DateTimeFormat("default", {
      month: "short"
    }).format
  },
  months: {
    getTickNumber: monthNumber,
    isTick: (prev, value) => value.getMonth() !== prev.getMonth(),
    format: new Intl.DateTimeFormat("default", {
      month: "short"
    }).format
  },
  biweekly: {
    getTickNumber: (from, to) => dayNumber(from, to) / 14,
    isTick: (prev, value) => (value.getDay() < prev.getDay() || dayNumber(value, prev) > 7) && Math.floor(value.getDate() / 7) % 2 === 1,
    format: new Intl.DateTimeFormat("default", {
      day: "numeric"
    }).format
  },
  weeks: {
    getTickNumber: (from, to) => dayNumber(from, to) / 7,
    isTick: (prev, value) => value.getDay() < prev.getDay() || dayNumber(value, prev) >= 7,
    format: new Intl.DateTimeFormat("default", {
      day: "numeric"
    }).format
  },
  days: {
    getTickNumber: dayNumber,
    isTick: (prev, value) => value.getDate() !== prev.getDate(),
    format: new Intl.DateTimeFormat("default", {
      day: "numeric"
    }).format
  },
  hours: {
    getTickNumber: hourNumber,
    isTick: (prev, value) => value.getHours() !== prev.getHours(),
    format: new Intl.DateTimeFormat("default", {
      hour: "2-digit",
      minute: "2-digit"
    }).format
  }
};

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function getTickPosition(scale, value, placement) {
  return scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[placement] * scale.step();
}
function applyTickSpacing(domain, range, tickSpacing) {
  const rangeSpan = Math.abs(range[1] - range[0]);
  const every = Math.ceil(domain.length / (rangeSpan / tickSpacing));
  if (Number.isNaN(every) || every <= 1) {
    return domain;
  }
  return domain.filter((_, index) => index % every === 0);
}
function getTimeTicks(domain, tickNumber, ticksFrequencies, scale, isInside) {
  if (ticksFrequencies.length === 0) {
    return [];
  }
  const isReversed = scale.range()[0] > scale.range()[1];
  const startIndex = domain.findIndex((value) => {
    return isInside(getTickPosition(scale, value, isReversed ? "start" : "end"));
  });
  const endIndex = domain.findLastIndex((value) => isInside(getTickPosition(scale, value, isReversed ? "end" : "start")));
  const start2 = domain[0];
  const end2 = domain[domain.length - 1];
  if (!(start2 instanceof Date) || !(end2 instanceof Date)) {
    return [];
  }
  let startFrequencyIndex = 0;
  for (let i = 0; i < ticksFrequencies.length; i += 1) {
    if (ticksFrequencies[i].getTickNumber(start2, end2) !== 0) {
      startFrequencyIndex = i;
      break;
    }
  }
  let endFrequencyIndex = startFrequencyIndex;
  for (let i = startFrequencyIndex; i < ticksFrequencies.length; i += 1) {
    if (i === ticksFrequencies.length - 1) {
      endFrequencyIndex = i;
      break;
    }
    const prevTickCount = ticksFrequencies[i].getTickNumber(start2, end2);
    const nextTickCount = ticksFrequencies[i + 1].getTickNumber(start2, end2);
    if (nextTickCount > tickNumber || tickNumber / prevTickCount < nextTickCount / tickNumber) {
      endFrequencyIndex = i;
      break;
    }
  }
  const ticks = [];
  for (let tickIndex = Math.max(1, startIndex); tickIndex <= endIndex; tickIndex += 1) {
    for (let i = startFrequencyIndex; i <= endFrequencyIndex; i += 1) {
      const prevDate = domain[tickIndex - 1];
      const currentDate = domain[tickIndex];
      if (prevDate instanceof Date && currentDate instanceof Date && ticksFrequencies[i].isTick(prevDate, currentDate)) {
        ticks.push({
          index: tickIndex,
          formatter: ticksFrequencies[i].format
        });
        break;
      }
    }
  }
  return ticks;
}
function getTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement: tickPlacementProp,
    tickLabelPlacement: tickLabelPlacementProp,
    tickSpacing,
    isInside,
    ordinalTimeTicks
  } = options;
  if (ordinalTimeTicks !== void 0 && isDateData(scale.domain()) && isOrdinalScale(scale)) {
    const domain2 = scale.domain();
    if (domain2.length === 0 || domain2.length === 1) {
      return [];
    }
    const tickPlacement2 = "middle";
    const ticksIndexes = getTimeTicks(domain2, tickNumber, ordinalTimeTicks.map((tickDef) => typeof tickDef === "string" ? tickFrequencies[tickDef] : tickDef), scale, isInside);
    return ticksIndexes.map(({
      index,
      formatter
    }) => {
      const value = domain2[index];
      const formattedValue = formatter(value);
      return {
        value,
        formattedValue,
        offset: getTickPosition(scale, value, tickPlacement2),
        labelOffset: 0
      };
    });
  }
  const tickPlacement = tickPlacementProp ?? "extremities";
  if (isOrdinalScale(scale)) {
    const domain2 = scale.domain();
    const tickLabelPlacement2 = tickLabelPlacementProp ?? "middle";
    let filteredDomain = domain2;
    if (typeof tickInterval === "object" && tickInterval != null) {
      filteredDomain = tickInterval;
    } else {
      if (typeof tickInterval === "function") {
        filteredDomain = filteredDomain.filter(tickInterval);
      }
      if (tickSpacing !== void 0 && tickSpacing > 0) {
        filteredDomain = applyTickSpacing(filteredDomain, scale.range(), tickSpacing);
      }
    }
    if (filteredDomain.length === 0) {
      return [];
    }
    if (scale.bandwidth() > 0) {
      const isReversed = scale.range()[0] > scale.range()[1];
      const startIndex = filteredDomain.findIndex((value) => {
        return isInside(getTickPosition(scale, value, isReversed ? "start" : "end"));
      });
      const endIndex = filteredDomain.findLastIndex((value) => isInside(getTickPosition(scale, value, isReversed ? "end" : "start")));
      return [...filteredDomain.slice(startIndex, endIndex + 1).map((value) => {
        const defaultTickLabel = `${value}`;
        return {
          value,
          formattedValue: valueFormatter?.(value, {
            location: "tick",
            scale,
            tickNumber,
            defaultTickLabel
          }) ?? defaultTickLabel,
          offset: getTickPosition(scale, value, tickPlacement),
          labelOffset: tickLabelPlacement2 === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement2] - offsetRatio[tickPlacement])
        };
      }), ...tickPlacement === "extremities" && endIndex === domain2.length - 1 && isInside(scale.range()[1]) ? [{
        formattedValue: void 0,
        offset: scale.range()[1],
        labelOffset: 0
      }] : []];
    }
    return filteredDomain.map((value) => {
      const defaultTickLabel = `${value}`;
      return {
        value,
        formattedValue: valueFormatter?.(value, {
          location: "tick",
          scale,
          tickNumber,
          defaultTickLabel
        }) ?? defaultTickLabel,
        offset: scale(value),
        labelOffset: 0
      };
    });
  }
  const domain = scale.domain();
  if (domain.some(isInfinity)) {
    return [];
  }
  const tickLabelPlacement = tickLabelPlacementProp;
  const ticks = typeof tickInterval === "object" ? tickInterval : getDefaultTicks(scale, tickNumber);
  const visibleTicks = [];
  for (let i = 0; i < ticks.length; i += 1) {
    const value = ticks[i];
    const offset2 = scale(value);
    if (isInside(offset2)) {
      const defaultTickLabel = scale.tickFormat(tickNumber)(value);
      visibleTicks.push({
        value,
        formattedValue: valueFormatter?.(value, {
          location: "tick",
          scale,
          tickNumber,
          defaultTickLabel
        }) ?? defaultTickLabel,
        offset: offset2,
        // Allowing the label to be placed in the middle of a continuous scale is weird.
        // But it is useful in some cases, like funnel categories with a linear scale.
        labelOffset: tickLabelPlacement === "middle" ? scale(ticks[i - 1] ?? 0) - (offset2 + scale(ticks[i - 1] ?? 0)) / 2 : 0
      });
    }
  }
  return visibleTicks;
}
function getDefaultTicks(scale, tickNumber) {
  const domain = scale.domain();
  if (domain[0] === domain[1]) {
    return [domain[0]];
  }
  return scale.ticks(tickNumber);
}
function useTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement,
    tickSpacing,
    direction,
    ordinalTimeTicks
  } = options;
  const {
    instance
  } = useChartContext();
  const isInside = direction === "x" ? instance.isXInside : instance.isYInside;
  return React9.useMemo(() => getTicks({
    scale,
    tickNumber,
    tickPlacement,
    tickInterval,
    tickLabelPlacement,
    tickSpacing,
    valueFormatter,
    isInside,
    ordinalTimeTicks
  }), [scale, tickNumber, tickPlacement, tickInterval, tickLabelPlacement, tickSpacing, valueFormatter, isInside, ordinalTimeTicks]);
}

// node_modules/@mui/x-charts/esm/hooks/useMounted.js
var React10 = __toESM(require_react(), 1);
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React10.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React10.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts/esm/internals/getGraphemeCount.js
var segmenter = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function getGraphemeCountFallback(text) {
  return text.length;
}
function getGraphemeCountModern(text) {
  const segments = segmenter.segment(text);
  let count = 0;
  for (const _unused of segments) {
    count += 1;
  }
  return count;
}
var getGraphemeCount = segmenter ? getGraphemeCountModern : getGraphemeCountFallback;

// node_modules/@mui/x-charts/esm/internals/degToRad.js
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

// node_modules/@mui/x-charts/esm/internals/sliceUntil.js
var segmenter2 = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function sliceUntilFallback(text, endIndex) {
  return text.slice(0, endIndex);
}
function sliceUntilModern(text, endIndex) {
  const segments = segmenter2.segment(text);
  let newText = "";
  let i = 0;
  for (const segment of segments) {
    newText += segment.segment;
    i += 1;
    if (i >= endIndex) {
      break;
    }
  }
  return newText;
}
var sliceUntil = segmenter2 ? sliceUntilModern : sliceUntilFallback;

// node_modules/@mui/x-charts/esm/internals/ellipsize.js
var ELLIPSIS = "â€¦";
function doesTextFitInRect(text, config) {
  const {
    width,
    height,
    measureText
  } = config;
  const angle = degToRad(config.angle);
  const textSize = measureText(text);
  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));
  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));
  return angledWidth <= width && angledHeight <= height;
}
function ellipsize(text, doesTextFit) {
  if (doesTextFit(text)) {
    return text;
  }
  let shortenedText = text;
  let step = 1;
  let by = 1 / 2;
  const graphemeCount = getGraphemeCount(text);
  let newLength = graphemeCount;
  let lastLength = graphemeCount;
  let longestFittingText = null;
  do {
    lastLength = newLength;
    newLength = Math.floor(graphemeCount * by);
    if (newLength === 0) {
      break;
    }
    shortenedText = sliceUntil(text, newLength).trim();
    const fits = doesTextFit(shortenedText + ELLIPSIS);
    step += 1;
    if (fits) {
      longestFittingText = shortenedText;
      by += 1 / 2 ** step;
    } else {
      by -= 1 / 2 ** step;
    }
  } while (Math.abs(newLength - lastLength) !== 1);
  return longestFittingText ? longestFittingText + ELLIPSIS : "";
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/shortenLabels.js
function shortenLabels(visibleLabels, drawingArea, maxHeight, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle(tickLabelStyle?.angle ?? 0);
  let leftBoundFactor = 1;
  let rightBoundFactor = 1;
  if (tickLabelStyle?.textAnchor === "start") {
    leftBoundFactor = Infinity;
    rightBoundFactor = 1;
  } else if (tickLabelStyle?.textAnchor === "end") {
    leftBoundFactor = 1;
    rightBoundFactor = Infinity;
  } else {
    leftBoundFactor = 2;
    rightBoundFactor = 2;
  }
  if (angle > 90 && angle < 270) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  if (isRtl) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const width = Math.min((item.offset + item.labelOffset) * leftBoundFactor, (drawingArea.left + drawingArea.width + drawingArea.right - item.offset - item.labelOffset) * rightBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width,
        height: maxHeight,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}

// node_modules/@mui/x-charts/esm/internals/geometry.js
var ANGLE_APPROX = 5;
function getMinXTranslation(width, height, angle = 0) {
  if (true) {
    if (angle > 90 && angle < -90) {
      warnOnce([`MUI X Charts: It seems you applied an angle larger than 90Â° or smaller than -90Â° to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height;
  }
  const radAngle = deg2rad(standardAngle);
  const angleSwich = Math.atan2(height, width);
  if (radAngle < angleSwich) {
    return width / Math.cos(radAngle);
  }
  return height / Math.sin(radAngle);
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/getVisibleLabels.js
function getVisibleLabels(xTicks, {
  tickLabelStyle: style,
  tickLabelInterval,
  tickLabelMinGap,
  reverse,
  isMounted,
  isXInside
}) {
  if (typeof tickLabelInterval === "function") {
    return new Set(xTicks.filter((item, index) => tickLabelInterval(item.value, index)));
  }
  let previousTextLimit = 0;
  const direction = reverse ? -1 : 1;
  const candidateTickLabels = xTicks.filter((item) => {
    const {
      offset: offset2,
      labelOffset,
      formattedValue
    } = item;
    if (formattedValue === "") {
      return false;
    }
    const textPosition = offset2 + labelOffset;
    return isXInside(textPosition);
  });
  const sizeMap = measureTickLabels(candidateTickLabels, style);
  return new Set(candidateTickLabels.filter((item, labelIndex) => {
    const {
      offset: offset2,
      labelOffset
    } = item;
    const textPosition = offset2 + labelOffset;
    if (labelIndex > 0 && direction * textPosition < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    const {
      width,
      height
    } = isMounted ? getTickLabelSize(sizeMap, item) : {
      width: 0,
      height: 0
    };
    const distance = getMinXTranslation(width, height, style?.angle);
    const currentTextLimit = textPosition - direction * distance / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    previousTextLimit = textPosition + direction * distance / 2;
    return true;
  }));
}
function getTickLabelSize(sizeMap, tick) {
  if (tick.formattedValue === void 0) {
    return {
      width: 0,
      height: 0
    };
  }
  let width = 0;
  let height = 0;
  for (const line of tick.formattedValue.split("\n")) {
    const lineSize = sizeMap.get(line);
    if (lineSize) {
      width = Math.max(width, lineSize.width);
      height += lineSize.height;
    }
  }
  return {
    width,
    height
  };
}
function measureTickLabels(ticks, style) {
  const strings = /* @__PURE__ */ new Set();
  for (const tick of ticks) {
    if (tick.formattedValue) {
      tick.formattedValue.split("\n").forEach((line) => strings.add(line));
    }
  }
  return batchMeasureStrings(strings, style);
}

// node_modules/@mui/x-charts/esm/ChartsAxis/axisClasses.js
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right", "id"]);

// node_modules/@mui/x-charts/esm/ChartsXAxis/utilities.js
var useUtilityClasses4 = (ownerState) => {
  const {
    classes,
    position,
    id
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position, `id-${id}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP = 3;
var AXIS_LABEL_TICK_LABEL_GAP = 4;
var defaultProps = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6,
  tickLabelMinGap: 4
};

// node_modules/@mui/x-charts/esm/ChartsText/defaultTextPlacement.js
function getDefaultTextAnchor(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "middle";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "middle";
  }
  if (adjustedAngle <= 180) {
    return "end";
  }
  return "start";
}
function getDefaultBaseline(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "hanging";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "auto";
  }
  return "central";
}

// node_modules/@mui/x-charts/esm/internals/invertTextAnchor.js
function invertTextAnchor(textAnchor) {
  switch (textAnchor) {
    case "start":
      return "end";
    case "end":
      return "start";
    default:
      return textAnchor;
  }
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/useAxisTicksProps.js
var _excluded7 = ["scale", "tickNumber", "reverse"];
function useAxisTicksProps(inProps) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded7);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    tickLabelStyle,
    slots,
    slotProps
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const classes = useUtilityClasses4(defaultizedProps);
  const positionSign = position === "bottom" ? 1 : -1;
  const Tick = slots?.axisTick ?? "line";
  const TickLabel = slots?.axisTickLabel ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position === "bottom" ? 0 : 180) - (tickLabelStyle?.angle ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position === "bottom" ? 0 : 180) - (tickLabelStyle?.angle ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    externalSlotProps: slotProps?.axisTickLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: 12,
        lineHeight: 1.25,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  return {
    xScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps,
    reverse
  };
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsSingleXAxisTicks.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function ChartsSingleXAxisTicks(inProps) {
  const {
    axisLabelHeight,
    ordinalTimeTicks
  } = inProps;
  const {
    xScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps,
    reverse
  } = useAxisTicksProps(inProps);
  const isRtl = useRtl();
  const isMounted = useMounted();
  const {
    disableTicks,
    tickSize: tickSizeProp,
    valueFormatter,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    tickLabelMinGap,
    tickSpacing,
    height: axisHeight
  } = defaultizedProps;
  const drawingArea = useDrawingArea();
  const {
    instance
  } = useChartContext();
  const isHydrated = useIsHydrated();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement,
    tickSpacing,
    direction: "x",
    ordinalTimeTicks
  });
  const visibleLabels = getVisibleLabels(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    tickLabelMinGap,
    reverse,
    isMounted,
    isXInside: instance.isXInside
  });
  const tickLabelsMaxHeight = Math.max(0, axisHeight - (axisLabelHeight > 0 ? axisLabelHeight + AXIS_LABEL_TICK_LABEL_GAP : 0) - tickSize - TICK_LABEL_GAP);
  const tickLabels = isHydrated ? shortenLabels(visibleLabels, drawingArea, tickLabelsMaxHeight, isRtl, axisTickLabelProps.style) : new Map(Array.from(visibleLabels).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime8.jsx)(React11.Fragment, {
    children: xTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + TICK_LABEL_GAP);
      const showTick = instance.isXInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      const showTickLabel = visibleLabels.has(item);
      return (0, import_jsx_runtime8.jsxs)("g", {
        transform: `translate(${tickOffset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime8.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== void 0 && showTickLabel && (0, import_jsx_runtime8.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: tickLabel
        }))]
      }, index);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsGroupedXAxisTicks.js
var React13 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/hooks/useTicksGrouped.js
var React12 = __toESM(require_react(), 1);
var offsetRatio2 = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5,
  tick: 0
};
function useTicksGrouped(options) {
  const {
    scale,
    tickInterval,
    tickLabelPlacement = "middle",
    tickPlacement = "extremities",
    groups
  } = options;
  return React12.useMemo(() => {
    const domain = scale.domain();
    const filteredDomain = typeof tickInterval === "function" && domain.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain;
    if (scale.bandwidth() > 0) {
      const entries = mapToGrouping(filteredDomain, groups, tickPlacement, tickLabelPlacement, scale);
      if (entries[0]) {
        entries[0].ignoreTick = true;
      }
      return [
        {
          formattedValue: void 0,
          offset: scale.range()[0],
          labelOffset: 0,
          groupIndex: groups.length - 1
        },
        ...entries,
        // Last tick
        {
          formattedValue: void 0,
          offset: scale.range()[1],
          labelOffset: 0,
          groupIndex: groups.length - 1
        }
      ];
    }
    return mapToGrouping(filteredDomain, groups, tickPlacement, tickLabelPlacement, scale);
  }, [scale, tickInterval, groups, tickPlacement, tickLabelPlacement]);
}
function mapToGrouping(tickValues, groups, tickPlacement, tickLabelPlacement, scale) {
  const allTickItems = [];
  const dataIndexToTickIndex = /* @__PURE__ */ new Map();
  let currentValueCount = 0;
  for (let groupIndex = 0; groupIndex < groups.length; groupIndex += 1) {
    for (let dataIndex = 0; dataIndex < tickValues.length; dataIndex += 1) {
      const tickValue = tickValues[dataIndex];
      const groupValue = groups[groupIndex].getValue(tickValue, dataIndex);
      const lastItem = allTickItems[allTickItems.length - 1];
      const isNew = lastItem?.value !== groupValue || lastItem?.groupIndex !== groupIndex;
      if (isNew) {
        currentValueCount = 1;
        const tickOffset = isOrdinalScale(scale) ? scale(tickValue) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio2[tickPlacement] * scale.step() : scale(tickValue);
        const labelOffset = scale.step() * currentValueCount * (offsetRatio2[tickLabelPlacement] - offsetRatio2[tickPlacement]);
        allTickItems.push({
          value: groupValue,
          formattedValue: `${groupValue}`,
          offset: tickOffset,
          groupIndex,
          dataIndex,
          ignoreTick: false,
          labelOffset
        });
        if (!dataIndexToTickIndex.has(dataIndex)) {
          dataIndexToTickIndex.set(dataIndex, /* @__PURE__ */ new Set());
        }
        const tickIndexes = dataIndexToTickIndex.get(dataIndex);
        for (const previousIndex of tickIndexes.values()) {
          allTickItems[previousIndex].ignoreTick = true;
        }
        tickIndexes.add(allTickItems.length - 1);
      } else {
        currentValueCount += 1;
        const labelOffset = scale.step() * currentValueCount * (offsetRatio2[tickLabelPlacement] - offsetRatio2[tickPlacement]);
        lastItem.labelOffset = labelOffset;
      }
    }
  }
  return allTickItems;
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsGroupedXAxisTicks.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_GROUPING_CONFIG = {
  tickSize: 6
};
var getGroupingConfig = (groups, groupIndex, tickSize) => {
  const config = groups[groupIndex] ?? {};
  const defaultTickSize = tickSize ?? DEFAULT_GROUPING_CONFIG.tickSize;
  const calculatedTickSize = defaultTickSize * groupIndex * 2 + defaultTickSize;
  return _extends({}, DEFAULT_GROUPING_CONFIG, config, {
    tickSize: config.tickSize ?? calculatedTickSize
  });
};
function ChartsGroupedXAxisTicks(inProps) {
  const {
    xScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps
  } = useAxisTicksProps(inProps);
  if (!isOrdinalScale(xScale)) {
    throw new Error("MUI X Charts: ChartsGroupedXAxis only supports the `band` and `point` scale types.");
  }
  const {
    disableTicks,
    tickSize,
    valueFormatter,
    slotProps,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  } = defaultizedProps;
  const groups = defaultizedProps.groups;
  const {
    instance
  } = useChartContext();
  const xTicks = useTicksGrouped({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement,
    direction: "x",
    groups
  });
  return (0, import_jsx_runtime9.jsx)(React13.Fragment, {
    children: xTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const xTickLabel = labelOffset ?? 0;
      const showTick = instance.isXInside(tickOffset);
      const tickLabel = item.formattedValue;
      const ignoreTick = item.ignoreTick ?? false;
      const groupIndex = item.groupIndex ?? 0;
      const groupConfig = getGroupingConfig(groups, groupIndex, tickSize);
      const tickYSize = positionSign * groupConfig.tickSize;
      const labelPositionY = positionSign * (groupConfig.tickSize + TICK_LABEL_GAP);
      return (0, import_jsx_runtime9.jsxs)("g", {
        transform: `translate(${tickOffset}, 0)`,
        className: classes.tickContainer,
        "data-group-index": groupIndex,
        children: [!disableTicks && !ignoreTick && showTick && (0, import_jsx_runtime9.jsx)(Tick, _extends({
          y2: tickYSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== void 0 && (0, import_jsx_runtime9.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: labelPositionY
        }, axisTickLabelProps, {
          style: _extends({}, axisTickLabelProps.style, groupConfig.tickLabelStyle),
          text: tickLabel
        }))]
      }, index);
    })
  });
}

// node_modules/@mui/x-charts/esm/internals/components/AxisSharedComponents.js
var AxisRoot = styled_default("g", {
  name: "MuiChartsAxis",
  slot: "Root"
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: {
    fill: (theme.vars || theme).palette.text.primary
  },
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxisImpl.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var _excluded8 = ["axis"];
var _excluded23 = ["scale", "tickNumber", "reverse", "ordinalTimeTicks"];
var XAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsXAxis",
  slot: "Root"
})({});
function ChartsXAxisImpl(_ref) {
  let {
    axis
  } = _ref, inProps = _objectWithoutPropertiesLoose(_ref, _excluded8);
  const {
    scale: xScale,
    ordinalTimeTicks
  } = axis, settings = _objectWithoutPropertiesLoose(axis, _excluded23);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    labelStyle,
    offset: offset2,
    slots,
    slotProps,
    sx,
    disableLine,
    label,
    height: axisHeight
  } = defaultizedProps;
  const theme = useTheme();
  const classes = useUtilityClasses4(defaultizedProps);
  const {
    left: left2,
    top: top2,
    width,
    height
  } = useDrawingArea();
  const positionSign = position === "bottom" ? 1 : -1;
  const Line = slots?.axisLine ?? "line";
  const Label = slots?.axisLabel ?? ChartsText;
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    externalSlotProps: slotProps?.axisLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "text-after-edge" : "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  if (position === "none") {
    return null;
  }
  const labelHeight = label ? getStringSize(label, axisLabelProps.style).height : 0;
  const domain = xScale.domain();
  const isScaleOrdinal = isOrdinalScale(xScale);
  const skipTickRendering = isScaleOrdinal ? domain.length === 0 : domain.some(isInfinity);
  let children = null;
  if (!skipTickRendering) {
    children = "groups" in axis && Array.isArray(axis.groups) ? (0, import_jsx_runtime10.jsx)(ChartsGroupedXAxisTicks, _extends({}, inProps)) : (0, import_jsx_runtime10.jsx)(ChartsSingleXAxisTicks, _extends({}, inProps, {
      axisLabelHeight: labelHeight,
      ordinalTimeTicks
    }));
  }
  const labelRefPoint = {
    x: left2 + width / 2,
    y: positionSign * axisHeight
  };
  return (0, import_jsx_runtime10.jsxs)(XAxisRoot, {
    transform: `translate(0, ${position === "bottom" ? top2 + height + offset2 : top2 - offset2})`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime10.jsx)(Line, _extends({
      x1: left2,
      x2: left2 + width,
      className: classes.line
    }, slotProps?.axisLine)), children, label && (0, import_jsx_runtime10.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime10.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function ChartsXAxis(inProps) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const axis = xAxis[inProps.axisId ?? xAxisIds[0]];
  if (!axis) {
    warnOnce(`MUI X Charts: No axis found. The axisId "${inProps.axisId}" is probably invalid.`);
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(ChartsXAxisImpl, _extends({}, inProps, {
    axis
  }));
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types5.default.oneOf(["x"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types5.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types5.default.bool,
  /**
   * The label of the axis.
   */
  label: import_prop_types5.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types5.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["auto"]), import_prop_types5.default.array, import_prop_types5.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["auto"]), import_prop_types5.default.func]),
  /**
   * The minimum gap in pixels between two tick labels.
   * If two tick labels are closer than this minimum gap, one of them will be hidden.
   * @default 4
   */
  tickLabelMinGap: import_prop_types5.default.number,
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types5.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types5.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types5.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types5.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types5.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types5.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types5.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxis.js
var import_prop_types6 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxisImpl.js
var React17 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsSingleYAxisTicks.js
var React15 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsYAxis/shortenLabels.js
function shortenLabels2(visibleLabels, drawingArea, maxWidth, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle(tickLabelStyle?.angle ?? 0);
  let topBoundFactor = 1;
  let bottomBoundFactor = 1;
  if (tickLabelStyle?.textAnchor === "start") {
    topBoundFactor = Infinity;
    bottomBoundFactor = 1;
  } else if (tickLabelStyle?.textAnchor === "end") {
    topBoundFactor = 1;
    bottomBoundFactor = Infinity;
  } else {
    topBoundFactor = 2;
    bottomBoundFactor = 2;
  }
  if (angle > 180) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  if (isRtl) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const height = Math.min((item.offset + item.labelOffset) * topBoundFactor, (drawingArea.top + drawingArea.height + drawingArea.bottom - item.offset - item.labelOffset) * bottomBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width: maxWidth,
        height,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}

// node_modules/@mui/x-charts/esm/ChartsYAxis/utilities.js
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    position,
    id
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position, `id-${id}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP2 = 2;
var AXIS_LABEL_TICK_LABEL_GAP2 = 2;
var defaultProps2 = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};

// node_modules/@mui/x-charts/esm/ChartsYAxis/useAxisTicksProps.js
var _excluded9 = ["scale", "tickNumber", "reverse"];
function useAxisTicksProps2(inProps) {
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded9);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    tickLabelStyle,
    slots,
    slotProps
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const classes = useUtilityClasses5(defaultizedProps);
  const positionSign = position === "right" ? 1 : -1;
  const tickFontSize = typeof tickLabelStyle?.fontSize === "number" ? tickLabelStyle.fontSize : 12;
  const Tick = slots?.axisTick ?? "line";
  const TickLabel = slots?.axisTickLabel ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position === "right" ? -90 : 90) - (tickLabelStyle?.angle ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position === "right" ? -90 : 90) - (tickLabelStyle?.angle ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    externalSlotProps: slotProps?.axisTickLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: tickFontSize,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  return {
    yScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps
  };
}

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsSingleYAxisTicks.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function ChartsSingleYAxisTicks(inProps) {
  const {
    axisLabelHeight,
    ordinalTimeTicks
  } = inProps;
  const {
    yScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps
  } = useAxisTicksProps2(inProps);
  const isRtl = useRtl();
  const {
    disableTicks,
    tickSize: tickSizeProp,
    valueFormatter,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    tickSpacing,
    width: axisWidth
  } = defaultizedProps;
  const drawingArea = useDrawingArea();
  const {
    instance
  } = useChartContext();
  const isHydrated = useIsHydrated();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickSpacing,
    direction: "y",
    ordinalTimeTicks
  });
  const tickLabelsMaxWidth = Math.max(0, axisWidth - (axisLabelHeight > 0 ? axisLabelHeight + AXIS_LABEL_TICK_LABEL_GAP2 : 0) - tickSize - TICK_LABEL_GAP2);
  const tickLabels = isHydrated ? shortenLabels2(yTicks, drawingArea, tickLabelsMaxWidth, isRtl, axisTickLabelProps.style) : new Map(Array.from(yTicks).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime12.jsx)(React15.Fragment, {
    children: yTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset,
        value
      } = item;
      const xTickLabel = positionSign * (tickSize + TICK_LABEL_GAP2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !tickLabelInterval?.(value, index);
      const showLabel = instance.isYInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      if (!showLabel) {
        return null;
      }
      return (0, import_jsx_runtime12.jsxs)("g", {
        transform: `translate(0, ${tickOffset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime12.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== void 0 && !skipLabel && (0, import_jsx_runtime12.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: tickLabel
        }, axisTickLabelProps))]
      }, index);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsGroupedYAxisTicks.js
var React16 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_GROUPING_CONFIG2 = {
  tickSize: 6
};
var getGroupingConfig2 = (groups, groupIndex, tickSize) => {
  const config = groups[groupIndex] ?? {};
  const defaultTickSize = tickSize ?? DEFAULT_GROUPING_CONFIG2.tickSize;
  const calculatedTickSize = defaultTickSize * groupIndex * 2 + defaultTickSize;
  return _extends({}, DEFAULT_GROUPING_CONFIG2, config, {
    tickSize: config.tickSize ?? calculatedTickSize
  });
};
function ChartsGroupedYAxisTicks(inProps) {
  const {
    yScale,
    defaultizedProps,
    tickNumber,
    positionSign,
    classes,
    Tick,
    TickLabel,
    axisTickLabelProps
  } = useAxisTicksProps2(inProps);
  if (!isOrdinalScale(yScale)) {
    throw new Error("MUI X Charts: ChartsGroupedYAxis only supports the `band` and `point` scale types.");
  }
  const {
    disableTicks,
    tickSize,
    valueFormatter,
    slotProps,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  } = defaultizedProps;
  const groups = defaultizedProps.groups;
  const {
    instance
  } = useChartContext();
  const yTicks = useTicksGrouped({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement,
    direction: "y",
    groups
  });
  return (0, import_jsx_runtime13.jsx)(React16.Fragment, {
    children: yTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const yTickLabel = labelOffset ?? 0;
      const showTick = instance.isYInside(tickOffset);
      const tickLabel = item.formattedValue;
      const ignoreTick = item.ignoreTick ?? false;
      const groupIndex = item.groupIndex ?? 0;
      const groupConfig = getGroupingConfig2(groups, groupIndex, tickSize);
      const tickXSize = positionSign * groupConfig.tickSize;
      const labelPositionX = positionSign * (groupConfig.tickSize + TICK_LABEL_GAP2);
      return (0, import_jsx_runtime13.jsxs)("g", {
        transform: `translate(0, ${tickOffset})`,
        className: classes.tickContainer,
        "data-group-index": groupIndex,
        children: [!disableTicks && !ignoreTick && showTick && (0, import_jsx_runtime13.jsx)(Tick, _extends({
          x2: tickXSize,
          className: classes.tick
        }, slotProps?.axisTick)), tickLabel !== void 0 && (0, import_jsx_runtime13.jsx)(TickLabel, _extends({
          x: labelPositionX,
          y: yTickLabel
        }, axisTickLabelProps, {
          style: _extends({}, axisTickLabelProps.style, groupConfig.tickLabelStyle),
          text: tickLabel
        }))]
      }, index);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxisImpl.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var _excluded10 = ["axis"];
var _excluded24 = ["scale", "tickNumber", "reverse", "ordinalTimeTicks"];
var YAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsYAxis",
  slot: "Root"
})({});
function ChartsYAxisImpl(_ref) {
  let {
    axis
  } = _ref, inProps = _objectWithoutPropertiesLoose(_ref, _excluded10);
  const {
    scale: yScale,
    ordinalTimeTicks
  } = axis, settings = _objectWithoutPropertiesLoose(axis, _excluded24);
  const isHydrated = useIsHydrated();
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    disableLine,
    label,
    labelStyle,
    offset: offset2,
    width: axisWidth,
    sx,
    slots,
    slotProps
  } = defaultizedProps;
  const theme = useTheme();
  const classes = useUtilityClasses5(defaultizedProps);
  const {
    left: left2,
    top: top2,
    width,
    height
  } = useDrawingArea();
  const positionSign = position === "right" ? 1 : -1;
  const Line = slots?.axisLine ?? "line";
  const Label = slots?.axisLabel ?? ChartsText;
  const lineProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps?.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    externalSlotProps: slotProps?.axisLabel,
    // @ts-expect-error `useSlotProps` applies `WithCommonProps` with adds a `style: React.CSSProperties` prop automatically.
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  if (position === "none") {
    return null;
  }
  const labelRefPoint = {
    x: positionSign * axisWidth,
    y: top2 + height / 2
  };
  const axisLabelHeight = label == null ? 0 : getStringSize(label, axisLabelProps.style).height;
  const domain = yScale.domain();
  const isScaleOrdinal = isOrdinalScale(yScale);
  const skipTickRendering = isScaleOrdinal ? domain.length === 0 : domain.some(isInfinity);
  let children = null;
  if (!skipTickRendering) {
    children = "groups" in axis && Array.isArray(axis.groups) ? (0, import_jsx_runtime14.jsx)(ChartsGroupedYAxisTicks, _extends({}, inProps)) : (0, import_jsx_runtime14.jsx)(ChartsSingleYAxisTicks, _extends({}, inProps, {
      axisLabelHeight,
      ordinalTimeTicks
    }));
  }
  return (0, import_jsx_runtime14.jsxs)(YAxisRoot, {
    transform: `translate(${position === "right" ? left2 + width + offset2 : left2 - offset2}, 0)`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime14.jsx)(Line, _extends({
      y1: top2,
      y2: top2 + height,
      className: classes.line
    }, lineProps)), children, label && isHydrated && (0, import_jsx_runtime14.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime14.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxis.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function ChartsYAxis(inProps) {
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const axis = yAxis[inProps.axisId ?? yAxisIds[0]];
  if (!axis) {
    warnOnce(`MUI X Charts: No axis found. The axisId "${inProps.axisId}" is probably invalid.`);
    return null;
  }
  return (0, import_jsx_runtime15.jsx)(ChartsYAxisImpl, _extends({}, inProps, {
    axis
  }));
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types6.default.oneOf(["y"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types6.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types6.default.bool,
  /**
   * The label of the axis.
   */
  label: import_prop_types6.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types6.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["auto"]), import_prop_types6.default.array, import_prop_types6.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["auto"]), import_prop_types6.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types6.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types6.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types6.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types6.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types6.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types6.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types6.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function ChartsAxis(props) {
  const {
    slots,
    slotProps
  } = props;
  const {
    xAxisIds,
    xAxis
  } = useXAxes();
  const {
    yAxisIds,
    yAxis
  } = useYAxes();
  return (0, import_jsx_runtime16.jsxs)(React18.Fragment, {
    children: [xAxisIds.map((axisId) => {
      if (!xAxis[axisId].position || xAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime16.jsx)(ChartsXAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    }), yAxisIds.map((axisId) => {
      if (!yAxis[axisId].position || yAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime16.jsx)(ChartsYAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    })]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_prop_types17 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/HTMLElementType/HTMLElementType.js
function HTMLElementType(props, propName, componentName, location, propFullName) {
  if (false) {
    return null;
  }
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null) {
    return null;
  }
  if (propValue && propValue.nodeType !== 1) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an HTMLElement.`);
  }
  return null;
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_prop_types10 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Typography/Typography.js
var React19 = __toESM(require_react(), 1);
var import_prop_types8 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Typography/typographyClasses.js
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
var typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);

// node_modules/@mui/material/esm/Typography/Typography.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
var extendSxProp = internal_createExtendSxProp();
var useUtilityClasses6 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize_default(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
var TypographyRoot = styled_default("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== "inherit" && styles[`align${capitalize_default(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];
  }
})(memoTheme_default(({
  theme
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
    props: {
      variant
    },
    style: value
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({
    props: {
      color
    },
    style: {
      color: (theme.vars || theme).palette[color].main
    }
  })), ...Object.entries(theme.palette?.text || {}).filter(([, value]) => typeof value === "string").map(([color]) => ({
    props: {
      color: `text${capitalize_default(color)}`
    },
    style: {
      color: (theme.vars || theme).palette.text[color]
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.paragraph,
    style: {
      marginBottom: 16
    }
  }]
})));
var defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
var Typography = React19.forwardRef(function Typography2(inProps, ref) {
  const {
    color,
    ...themeProps
  } = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color];
  const props = extendSxProp({
    ...themeProps,
    ...isSxColor && {
      color
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses6(ownerState);
  return (0, import_jsx_runtime17.jsx)(TypographyRoot, {
    as: Component,
    ref,
    className: clsx_default(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
true ? Typography.propTypes = {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ These PropTypes are generated from the TypeScript type definitions. â”‚
  // â”‚    To update them, edit the d.ts file and run `pnpm proptypes`.     â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: import_prop_types8.default.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: import_prop_types8.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object,
  /**
   * @ignore
   */
  className: import_prop_types8.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["primary", "secondary", "success", "error", "info", "warning", "textPrimary", "textSecondary", "textDisabled"]), import_prop_types8.default.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types8.default.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: import_prop_types8.default.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: import_prop_types8.default.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   * @deprecated Use the `component` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  paragraph: import_prop_types8.default.bool,
  /**
   * @ignore
   */
  style: import_prop_types8.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), import_prop_types8.default.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: import_prop_types8.default.object
} : void 0;
var Typography_default = Typography;

// node_modules/@mui/x-charts/esm/ChartsTooltip/chartsTooltipClasses.js
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markContainer", "labelCell", "valueCell", "axisValueCell"]);
var useUtilityClasses7 = (classes) => {
  const slots = {
    root: ["root"],
    paper: ["paper"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markContainer: ["markContainer"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"],
    axisValueCell: ["axisValueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/ChartsTooltip/useItemTooltip.js
function useInternalItemTooltip() {
  const store = useStore();
  const identifier = store.use(selectorChartsTooltipItem);
  const seriesConfig = store.use(selectorChartSeriesConfig);
  const series = useSeries();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis,
    rotationAxisIds
  } = useRotationAxes();
  if (!identifier) {
    return null;
  }
  const itemSeries = series[identifier.type]?.series[identifier.seriesId];
  if (!itemSeries) {
    return null;
  }
  const xAxisId = isCartesianSeries(itemSeries) ? itemSeries.xAxisId ?? xAxisIds[0] : void 0;
  const yAxisId = isCartesianSeries(itemSeries) ? itemSeries.yAxisId ?? yAxisIds[0] : void 0;
  const zAxisId = "zAxisId" in itemSeries ? itemSeries.zAxisId ?? zAxisIds[0] : zAxisIds[0];
  const rotationAxisId = rotationAxisIds[0];
  const getColor = seriesConfig[itemSeries.type].colorProcessor?.(itemSeries, xAxisId !== void 0 ? xAxis[xAxisId] : void 0, yAxisId !== void 0 ? yAxis[yAxisId] : void 0, zAxisId !== void 0 ? zAxis[zAxisId] : void 0) ?? (() => "");
  const axesConfig = {};
  if (xAxisId !== void 0) {
    axesConfig.x = xAxis[xAxisId];
  }
  if (yAxisId !== void 0) {
    axesConfig.y = yAxis[yAxisId];
  }
  if (rotationAxisId !== void 0) {
    axesConfig.rotation = rotationAxis[rotationAxisId];
  }
  return seriesConfig[itemSeries.type].tooltipGetter({
    series: itemSeries,
    axesConfig,
    getColor,
    identifier
  });
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (props, styles) => styles.paper
  // FIXME: Inconsistent naming with slot
})(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  borderRadius: (theme.vars || theme).shape?.borderRadius,
  border: `solid ${(theme.vars || theme).palette.divider} 1px`
}));
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme
}) => ({
  borderSpacing: 0,
  [`& .${chartsTooltipClasses.markContainer}`]: {
    display: "inline-block",
    width: `calc(20px + ${theme.spacing(1.5)})`,
    verticalAlign: "middle"
  },
  "& caption": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`,
    padding: theme.spacing(0.5, 1.5),
    textAlign: "start",
    whiteSpace: "nowrap",
    "& span": {
      marginRight: theme.spacing(1.5)
    }
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(0.5)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(0.5)
  }
}));
var ChartsTooltipCell = styled_default(Typography_default, {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  textAlign: "start",
  [`&.${chartsTooltipClasses.cell}`]: {
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.labelCell}`]: {
    whiteSpace: "nowrap",
    fontWeight: theme.typography.fontWeightRegular
  },
  [`&.${chartsTooltipClasses.valueCell}, &.${chartsTooltipClasses.axisValueCell}`]: {
    color: (theme.vars || theme).palette.text.primary,
    fontWeight: theme.typography.fontWeightMedium
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(1.5),
    paddingRight: theme.spacing(1.5)
  },
  "td:first-of-type&, th:first-of-type&": {
    paddingLeft: theme.spacing(1.5)
  },
  "td:last-of-type&, th:last-of-type&": {
    paddingRight: theme.spacing(1.5)
  }
}));

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var React21 = __toESM(require_react(), 1);
var import_prop_types9 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelMarkClasses.js
function getLabelMarkUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelMark", slot);
}
var labelMarkClasses = generateUtilityClasses("MuiChartsLabelMark", ["root", "line", "square", "circle", "mask", "fill"]);
var useUtilityClasses8 = (props) => {
  const {
    type
  } = props;
  const slots = {
    root: typeof type === "function" ? ["root"] : ["root", type],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelMarkUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/internals/consumeThemeProps.js
var React20 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var consumeThemeProps = (name, options, InComponent) => React20.forwardRef(function ConsumeThemeInternal(props, ref) {
  const themedProps = useThemeProps({
    props,
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    name
  });
  const defaultProps3 = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
  const outProps = resolveProps(defaultProps3, themedProps);
  const theme = useTheme();
  const classes = options.classesResolver?.(outProps, theme);
  const OutComponent = React20.forwardRef(InComponent);
  if (true) OutComponent.displayName = "OutComponent";
  if (true) {
    OutComponent.displayName = `consumeThemeProps(${name})`;
  }
  return (0, import_jsx_runtime18.jsx)(OutComponent, _extends({}, outProps, {
    classes,
    ref
  }));
});
if (true) consumeThemeProps.displayName = "consumeThemeProps";

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var _excluded11 = ["type", "color", "className", "classes"];
var Root = styled_default("div", {
  name: "MuiChartsLabelMark",
  slot: "Root"
})(() => {
  return {
    display: "flex",
    width: 14,
    height: 14,
    [`&.${labelMarkClasses.line}`]: {
      width: 16,
      height: "unset",
      alignItems: "center",
      [`.${labelMarkClasses.mask}`]: {
        height: 4,
        width: "100%",
        borderRadius: 1,
        overflow: "hidden"
      }
    },
    [`&.${labelMarkClasses.square}`]: {
      height: 13,
      width: 13,
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelMarkClasses.circle}`]: {
      height: 15,
      width: 15
    },
    svg: {
      display: "block"
    },
    [`& .${labelMarkClasses.mask} > *`]: {
      height: "100%",
      width: "100%"
    },
    [`& .${labelMarkClasses.mask}`]: {
      height: "100%",
      width: "100%"
    }
  };
});
var ChartsLabelMark = consumeThemeProps("MuiChartsLabelMark", {
  defaultProps: {
    type: "square"
  },
  classesResolver: useUtilityClasses8
}, function ChartsLabelMark2(props, ref) {
  const {
    type,
    color,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const Component = type;
  return (0, import_jsx_runtime19.jsx)(Root, _extends({
    className: clsx_default(classes?.root, className),
    ownerState: props,
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime19.jsx)("div", {
      className: classes?.mask,
      children: typeof Component === "function" ? (0, import_jsx_runtime19.jsx)(Component, {
        className: classes?.fill,
        color
      }) : (0, import_jsx_runtime19.jsx)("svg", {
        viewBox: "0 0 24 24",
        preserveAspectRatio: type === "line" ? "none" : void 0,
        children: type === "circle" ? (0, import_jsx_runtime19.jsx)("circle", {
          className: classes?.fill,
          r: "12",
          cx: "12",
          cy: "12",
          fill: color
        }) : (0, import_jsx_runtime19.jsx)("rect", {
          className: classes?.fill,
          width: "24",
          height: "24",
          fill: color
        })
      })
    })
  }));
});
true ? ChartsLabelMark.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types9.default.object,
  /**
   * The color of the mark.
   */
  color: import_prop_types9.default.string,
  /**
   * The type of the mark.
   * @default 'square'
   */
  type: import_prop_types9.default.oneOf(["circle", "line", "square"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function ChartsItemTooltipContent(props) {
  const {
    classes: propClasses,
    sx
  } = props;
  const tooltipData = useInternalItemTooltip();
  const classes = useUtilityClasses7(propClasses);
  if (!tooltipData) {
    return null;
  }
  if ("values" in tooltipData) {
    const {
      label: seriesLabel,
      color: color2,
      markType: markType2
    } = tooltipData;
    return (0, import_jsx_runtime20.jsx)(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: (0, import_jsx_runtime20.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [(0, import_jsx_runtime20.jsxs)(Typography_default, {
          component: "caption",
          children: [(0, import_jsx_runtime20.jsx)("div", {
            className: classes.markContainer,
            children: (0, import_jsx_runtime20.jsx)(ChartsLabelMark, {
              type: markType2,
              color: color2,
              className: classes.mark
            })
          }), seriesLabel]
        }), (0, import_jsx_runtime20.jsx)("tbody", {
          children: tooltipData.values.map(({
            formattedValue: formattedValue2,
            label: label2
          }) => (0, import_jsx_runtime20.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime20.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              component: "th",
              children: label2
            }), (0, import_jsx_runtime20.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              component: "td",
              children: formattedValue2
            })]
          }, label2))
        })]
      })
    });
  }
  const {
    color,
    label,
    formattedValue,
    markType
  } = tooltipData;
  return (0, import_jsx_runtime20.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime20.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime20.jsx)("tbody", {
        children: (0, import_jsx_runtime20.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime20.jsxs)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            component: "th",
            children: [(0, import_jsx_runtime20.jsx)("div", {
              className: classes.markContainer,
              children: (0, import_jsx_runtime20.jsx)(ChartsLabelMark, {
                type: markType,
                color,
                className: classes.mark
              })
            }), label]
          }), (0, import_jsx_runtime20.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            component: "td",
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? ChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types10.default.object,
  sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_prop_types11 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useColorProcessor.js
var React22 = __toESM(require_react(), 1);
function useColorProcessor(seriesType) {
  const store = useStore();
  const seriesConfig = store.use(selectorChartSeriesConfig);
  const colorProcessors = React22.useMemo(() => {
    const rep = {};
    Object.keys(seriesConfig).forEach((seriesT) => {
      rep[seriesT] = seriesConfig[seriesT].colorProcessor;
    });
    return rep;
  }, [seriesConfig]);
  if (!seriesType) {
    return colorProcessors;
  }
  return colorProcessors[seriesType];
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
var React23 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/useMediaQuery/index.js
var useMediaQuery = unstable_createUseMediaQuery({
  themeId: identifier_default
});
var useMediaQuery_default = useMediaQuery;

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
function usePointerType() {
  const svgRef = useSvgRef();
  const [pointerType, setPointerType] = React23.useState(null);
  React23.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setPointerType(null);
      }
    };
    const handleEnter = (event) => {
      setPointerType({
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerenter", handleEnter);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerenter", handleEnter);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return pointerType;
}
function utcFormatter(v) {
  if (v instanceof Date) {
    return v.toUTCString();
  }
  return v.toLocaleString();
}
var mainPointerFineMediaQuery = "@media (pointer: fine)";
var useIsFineMainPointer = () => {
  return useMediaQuery_default(mainPointerFineMediaQuery, {
    defaultMatches: true
  });
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarInteraction.selectors.js
var optionalGetAxisId = (_, id) => id;
var optionalGetAxisIds = (_, ids) => ids;
function indexGetter(value, axes, ids) {
  return Array.isArray(ids) ? ids.map((id) => getAxisIndex(axes.axis[id], value)) : getAxisIndex(axes.axis[ids], value);
}
var selectorChartsInteractionRotationAngle = createSelector(selectorChartsInteractionPointerX, selectorChartsInteractionPointerY, selectorChartPolarCenter, (x, y, center) => {
  if (x === null || y === null) {
    return null;
  }
  return generateSvg2rotation(center)(x, y);
});
var selectorChartsInteractionRotationAxisIndex = createSelector(selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisId, (rotation, rotationAxis, id = rotationAxis.axisIds[0]) => rotation === null ? null : indexGetter(rotation, rotationAxis, id));
var selectorChartsInteractionRotationAxisIndexes = createSelector(selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisIds, (rotation, rotationAxis, ids = rotationAxis.axisIds) => rotation === null ? null : indexGetter(rotation, rotationAxis, ids));
var selectorChartsInteractionRotationAxisValue = createSelector(selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndex, optionalGetAxisId, (rotationAxis, rotationIndex, id = rotationAxis.axisIds[0]) => {
  if (rotationIndex === null || rotationIndex === -1 || rotationAxis.axisIds.length === 0) {
    return null;
  }
  const data = rotationAxis.axis[id]?.data;
  if (!data) {
    return null;
  }
  return data[rotationIndex];
});
var selectorChartsInteractionRotationAxisValues = createSelector(selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndexes, optionalGetAxisIds, (rotationAxis, rotationIndexes, ids = rotationAxis.axisIds) => {
  if (rotationIndexes === null) {
    return null;
  }
  return ids.map((id, axisIndex) => {
    const rotationIndex = rotationIndexes[axisIndex];
    if (rotationIndex === -1) {
      return null;
    }
    return rotationAxis.axis[id].data?.[rotationIndex];
  });
});
var selectorChartsInteractionTooltipRotationAxes = createSelectorMemoizedWithOptions({
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: isDeepEqual
  }
})(selectorChartsInteractionRotationAxisIndexes, selectorChartRotationAxis, (indexes, axes) => {
  if (indexes === null) {
    return [];
  }
  return axes.axisIds.map((axisId, axisIndex) => ({
    axisId,
    dataIndex: indexes[axisIndex]
  })).filter(({
    axisId,
    dataIndex
  }) => axes.axis[axisId].triggerTooltip && dataIndex >= 0);
});
var selectorChartsInteractionPolarAxisTooltip = createSelector(selectorChartsInteractionTooltipRotationAxes, (rotationTooltip) => rotationTooltip.length > 0);

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxisTooltip.js
function defaultAxisTooltipConfig(axis, dataIndex, axisDirection) {
  const axisValue = axis.data?.[dataIndex] ?? null;
  const axisFormatter = axis.valueFormatter ?? ((v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString());
  const axisFormattedValue = axisFormatter(axisValue, {
    location: "tooltip",
    scale: axis.scale
  });
  return {
    axisDirection,
    axisId: axis.id,
    mainAxis: axis,
    dataIndex,
    axisValue,
    axisFormattedValue,
    seriesItems: []
  };
}
function useAxisTooltip(params = {}) {
  const {
    multipleAxes,
    directions
  } = params;
  const defaultXAxis = useXAxis();
  const defaultYAxis = useYAxis();
  const defaultRotationAxis = useRotationAxis();
  const store = useStore();
  const tooltipXAxes = store.use(selectorChartsInteractionTooltipXAxes);
  const tooltipYAxes = store.use(selectorChartsInteractionTooltipYAxes);
  const tooltipRotationAxes = store.use(selectorChartsInteractionTooltipRotationAxes);
  const series = useSeries();
  const {
    xAxis
  } = useXAxes();
  const {
    yAxis
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis
  } = useRotationAxes();
  const colorProcessors = useColorProcessor();
  if (tooltipXAxes.length === 0 && tooltipYAxes.length === 0 && tooltipRotationAxes.length === 0) {
    return null;
  }
  const tooltipAxes = [];
  if (directions === void 0 || directions.includes("x")) {
    tooltipXAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(xAxis[axisId], dataIndex, "x"));
    });
  }
  if (directions === void 0 || directions.includes("y")) {
    tooltipYAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(yAxis[axisId], dataIndex, "y"));
    });
  }
  if (directions === void 0 || directions.includes("rotation")) {
    tooltipRotationAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(rotationAxis[axisId], dataIndex, "rotation"));
    });
  }
  Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedXAxisId = seriesToAdd.xAxisId ?? defaultXAxis.id;
      const providedYAxisId = seriesToAdd.yAxisId ?? defaultYAxis.id;
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "x" && axisId === providedXAxisId || axisDirection === "y" && axisId === providedYAxisId);
      if (tooltipItemIndex >= 0) {
        const zAxisId = "zAxisId" in seriesToAdd ? seriesToAdd.zAxisId : zAxisIds[0];
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color = colorProcessors[seriesType]?.(seriesToAdd, xAxis[providedXAxisId], yAxis[providedYAxisId], zAxisId ? zAxis[zAxisId] : void 0)(dataIndex) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  Object.keys(series).filter(isPolarSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedRotationAxisId = (
        // @ts-expect-error Should be fixed when we introduce a polar series with a rotationAxisId
        seriesToAdd.rotationAxisId ?? defaultRotationAxis?.id
      );
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "rotation" && axisId === providedRotationAxisId);
      if (tooltipItemIndex >= 0) {
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color = colorProcessors[seriesType]?.(seriesToAdd)(dataIndex) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  if (!multipleAxes) {
    return tooltipAxes.length === 0 ? tooltipAxes[0] : null;
  }
  return tooltipAxes;
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxesTooltip.js
function useAxesTooltip(params) {
  return useAxisTooltip(_extends({}, params, {
    multipleAxes: true
  }));
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function ChartsAxisTooltipContent(props) {
  const classes = useUtilityClasses7(props.classes);
  const tooltipData = useAxesTooltip();
  if (tooltipData === null) {
    return null;
  }
  return (0, import_jsx_runtime21.jsx)(ChartsTooltipPaper, {
    sx: props.sx,
    className: classes.paper,
    children: tooltipData.map(({
      axisId,
      mainAxis,
      axisValue,
      axisFormattedValue,
      seriesItems
    }) => {
      return (0, import_jsx_runtime21.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [axisValue != null && !mainAxis.hideTooltip && (0, import_jsx_runtime21.jsx)(Typography_default, {
          component: "caption",
          children: axisFormattedValue
        }), (0, import_jsx_runtime21.jsx)("tbody", {
          children: seriesItems.map(({
            seriesId,
            color,
            formattedValue,
            formattedLabel,
            markType
          }) => {
            if (formattedValue == null) {
              return null;
            }
            return (0, import_jsx_runtime21.jsxs)(ChartsTooltipRow, {
              className: classes.row,
              children: [(0, import_jsx_runtime21.jsxs)(ChartsTooltipCell, {
                className: clsx_default(classes.labelCell, classes.cell),
                component: "th",
                children: [(0, import_jsx_runtime21.jsx)("div", {
                  className: classes.markContainer,
                  children: (0, import_jsx_runtime21.jsx)(ChartsLabelMark, {
                    type: markType,
                    color,
                    className: classes.mark
                  })
                }), formattedLabel || null]
              }), (0, import_jsx_runtime21.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.valueCell, classes.cell),
                component: "td",
                children: formattedValue
              })]
            }, seriesId);
          })
        })]
      }, axisId);
    })
  });
}
true ? ChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types11.default.object,
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var React28 = __toESM(require_react(), 1);
var import_prop_types16 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Popper/Popper.js
var import_prop_types14 = __toESM(require_prop_types(), 1);
var React26 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/Popper/BasePopper.js
var React25 = __toESM(require_react(), 1);

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument2 = node.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@mui/material/esm/Popper/BasePopper.js
var import_prop_types13 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Portal/Portal.js
var React24 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var import_prop_types12 = __toESM(require_prop_types(), 1);
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
var Portal = React24.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React24.useState(null);
  const handleRef = useForkRef(React24.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect_default(() => {
    if (!disablePortal) {
      setMountNode(getContainer(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect_default(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (React24.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return React24.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? ReactDOM.createPortal(children, mountNode) : mountNode;
});
true ? Portal.propTypes = {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ These PropTypes are generated from the TypeScript type definitions. â”‚
  // â”‚ To update them, edit the TypeScript types and run `pnpm proptypes`. â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  /**
   * The children to render into the `container`.
   */
  children: import_prop_types12.default.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types12.default.oneOfType([HTMLElementType, import_prop_types12.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types12.default.bool
} : void 0;
if (true) {
  Portal["propTypes"] = exactProp(Portal.propTypes);
}
var Portal_default = Portal;

// node_modules/@mui/material/esm/Popper/popperClasses.js
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
var popperClasses = generateUtilityClasses("MuiPopper", ["root"]);

// node_modules/@mui/material/esm/Popper/BasePopper.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement2(element) {
  return element.nodeType !== void 0;
}
function isVirtualElement(element) {
  return !isHTMLElement2(element);
}
var useUtilityClasses9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes);
};
var defaultPopperOptions = {};
var PopperTooltip = React25.forwardRef(function PopperTooltip2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    // @ts-ignore internal logic
    ownerState: ownerStateProp,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...other
  } = props;
  const tooltipRef = React25.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = React25.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = React25.useRef(handlePopperRef);
  useEnhancedEffect_default(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React25.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = React25.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = React25.useState(resolveAnchorEl(anchorEl));
  React25.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  React25.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect_default(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    if (true) {
      if (resolvedAnchorElement && isHTMLElement2(resolvedAnchorElement) && resolvedAnchorElement.nodeType === 1) {
        const box = resolvedAnchorElement.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      }
    }
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper3(resolvedAnchorElement, tooltipRef.current, {
      placement: rtlPlacement,
      ...popperOptions,
      modifiers: popperModifiers
    });
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses9(props);
  const Root4 = slots.root ?? "div";
  const rootProps = useSlotProps_default({
    elementType: Root4,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return (0, import_jsx_runtime22.jsx)(Root4, {
    ...rootProps,
    children: typeof children === "function" ? children(childProps) : children
  });
});
var Popper = React25.forwardRef(function Popper2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style,
    transition = false,
    slotProps = {},
    slots = {},
    ...other
  } = props;
  const [exited, setExited] = React25.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    container = resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return (0, import_jsx_runtime22.jsx)(Portal_default, {
    disablePortal,
    container,
    children: (0, import_jsx_runtime22.jsx)(PopperTooltip, {
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots,
      ...other,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display,
        ...style
      },
      TransitionProps: transitionProps,
      children
    })
  });
});
true ? Popper.propTypes = {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ These PropTypes are generated from the TypeScript type definitions. â”‚
  // â”‚ To update them, edit the TypeScript types and run `pnpm proptypes`. â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: chainPropTypes(import_prop_types13.default.oneOfType([HTMLElementType, import_prop_types13.default.object, import_prop_types13.default.func]), (props) => {
    if (props.open) {
      const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
      if (resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== "function" || isVirtualElement(resolvedAnchorEl) && resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join("\n"));
      }
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: import_prop_types13.default.oneOfType([import_prop_types13.default.node, import_prop_types13.default.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types13.default.oneOfType([HTMLElementType, import_prop_types13.default.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: import_prop_types13.default.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types13.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types13.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types13.default.arrayOf(import_prop_types13.default.shape({
    data: import_prop_types13.default.object,
    effect: import_prop_types13.default.func,
    enabled: import_prop_types13.default.bool,
    fn: import_prop_types13.default.func,
    name: import_prop_types13.default.any,
    options: import_prop_types13.default.object,
    phase: import_prop_types13.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types13.default.arrayOf(import_prop_types13.default.string),
    requiresIfExists: import_prop_types13.default.arrayOf(import_prop_types13.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types13.default.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types13.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types13.default.shape({
    modifiers: import_prop_types13.default.array,
    onFirstUpdate: import_prop_types13.default.func,
    placement: import_prop_types13.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types13.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType_default,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types13.default.shape({
    root: import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types13.default.shape({
    root: import_prop_types13.default.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types13.default.bool
} : void 0;
var BasePopper_default = Popper;

// node_modules/@mui/material/esm/Popper/Popper.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var PopperRoot = styled_default(BasePopper_default, {
  name: "MuiPopper",
  slot: "Root"
})({});
var Popper3 = React26.forwardRef(function Popper4(inProps, ref) {
  const isRtl = useRtl();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps,
    ...other
  } = props;
  const RootComponent = slots?.root ?? components?.Root;
  const otherProps = {
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    ...other
  };
  return (0, import_jsx_runtime23.jsx)(PopperRoot, {
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps ?? componentsProps,
    ...otherProps,
    ref
  });
});
true ? Popper3.propTypes = {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ These PropTypes are generated from the TypeScript type definitions. â”‚
  // â”‚ To update them, edit the TypeScript types and run `pnpm proptypes`. â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types14.default.oneOfType([HTMLElementType, import_prop_types14.default.object, import_prop_types14.default.func]),
  /**
   * Popper render function or node.
   */
  children: import_prop_types14.default.oneOfType([import_prop_types14.default.node, import_prop_types14.default.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types14.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types14.default.shape({
    Root: import_prop_types14.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types14.default.shape({
    root: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types14.default.oneOfType([HTMLElementType, import_prop_types14.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types14.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types14.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    data: import_prop_types14.default.object,
    effect: import_prop_types14.default.func,
    enabled: import_prop_types14.default.bool,
    fn: import_prop_types14.default.func,
    name: import_prop_types14.default.any,
    options: import_prop_types14.default.object,
    phase: import_prop_types14.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types14.default.arrayOf(import_prop_types14.default.string),
    requiresIfExists: import_prop_types14.default.arrayOf(import_prop_types14.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types14.default.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types14.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types14.default.shape({
    modifiers: import_prop_types14.default.array,
    onFirstUpdate: import_prop_types14.default.func,
    placement: import_prop_types14.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types14.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType_default,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types14.default.shape({
    root: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types14.default.shape({
    root: import_prop_types14.default.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types14.default.bool
} : void 0;
var Popper_default = Popper3;

// node_modules/@mui/material/esm/NoSsr/NoSsr.js
var React27 = __toESM(require_react(), 1);
var import_prop_types15 = __toESM(require_prop_types(), 1);
function NoSsr(props) {
  const {
    children,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = React27.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React27.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState ? children : fallback;
}
true ? NoSsr.propTypes = {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ These PropTypes are generated from the TypeScript type definitions. â”‚
  // â”‚ To update them, edit the TypeScript types and run `pnpm proptypes`. â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  /**
   * You can wrap a node.
   */
  children: import_prop_types15.default.node,
  /**
   * If `true`, the component will not only prevent server-side rendering.
   * It will also defer the rendering of the children into a different screen frame.
   * @default false
   */
  defer: import_prop_types15.default.bool,
  /**
   * The fallback content to display.
   * @default null
   */
  fallback: import_prop_types15.default.node
} : void 0;
if (true) {
  NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
}
var NoSsr_default = NoSsr;

// node_modules/@mui/x-internals/esm/rafThrottle/rafThrottle.js
function rafThrottle(fn2) {
  let lastArgs;
  let rafRef;
  const later = () => {
    rafRef = null;
    fn2(...lastArgs);
  };
  function throttled(...args) {
    lastArgs = args;
    if (!rafRef) {
      rafRef = requestAnimationFrame(later);
    }
  }
  throttled.clear = () => {
    if (rafRef) {
      cancelAnimationFrame(rafRef);
      rafRef = null;
    }
  };
  return throttled;
}

// node_modules/@mui/x-charts/esm/hooks/useAxisSystem.js
function useAxisSystem() {
  const store = useStore();
  const rawRotationAxis = store.use(selectorChartRawRotationAxis);
  const rawXAxis = store.use(selectorChartRawXAxis);
  if (rawRotationAxis !== void 0) {
    return "polar";
  }
  if (rawXAxis !== void 0) {
    return "cartesian";
  }
  return "none";
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var _excluded12 = ["trigger", "position", "anchor", "classes", "children"];
var selectorReturnFalse = () => false;
var selectorReturnNull = () => null;
function getIsOpenSelector(trigger, axisSystem, shouldPreventBecauseOfBrush) {
  if (shouldPreventBecauseOfBrush) {
    return selectorReturnFalse;
  }
  if (trigger === "item") {
    return selectorChartsTooltipItemIsDefined;
  }
  if (axisSystem === "polar") {
    return selectorChartsInteractionPolarAxisTooltip;
  }
  if (axisSystem === "cartesian") {
    return selectorChartsInteractionAxisTooltip;
  }
  return selectorReturnFalse;
}
var ChartsTooltipRoot = styled_default(Popper_default, {
  name: "MuiChartsTooltip",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltipContainer(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsTooltipContainer"
  });
  const {
    trigger = "axis",
    position,
    anchor = "pointer",
    classes: propClasses,
    children
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const svgRef = useSvgRef();
  const classes = useUtilityClasses7(propClasses);
  const pointerType = usePointerType();
  const isFineMainPointer = useIsFineMainPointer();
  const popperRef = React28.useRef(null);
  const positionRef = useLazyRef(() => ({
    x: 0,
    y: 0
  }));
  const axisSystem = useAxisSystem();
  const store = useStore();
  const shouldPreventBecauseOfBrush = store.use(selectorBrushShouldPreventTooltip);
  const isOpen = store.use(getIsOpenSelector(trigger, axisSystem, shouldPreventBecauseOfBrush));
  const lastInteraction = store.use(selectorChartsLastInteraction);
  const computedAnchor = lastInteraction === "keyboard" ? "node" : anchor;
  const itemPosition = store.use(trigger === "item" && computedAnchor === "node" ? selectorChartsTooltipItemPosition : selectorReturnNull, position);
  React28.useEffect(() => {
    const svgElement = svgRef.current;
    if (svgElement === null) {
      return () => {
      };
    }
    if (itemPosition !== null) {
      const positionUpdate = rafThrottle(() => {
        positionRef.current = {
          x: svgElement.getBoundingClientRect().left + (itemPosition?.x ?? 0),
          y: svgElement.getBoundingClientRect().top + (itemPosition?.y ?? 0)
        };
        popperRef.current?.update();
      });
      positionUpdate();
      return () => positionUpdate.clear();
    }
    const pointerUpdate = rafThrottle((x, y) => {
      positionRef.current = {
        x,
        y
      };
      popperRef.current?.update();
    });
    const handlePointerEvent = (event) => {
      pointerUpdate(event.clientX, event.clientY);
    };
    svgElement.addEventListener("pointerdown", handlePointerEvent);
    svgElement.addEventListener("pointermove", handlePointerEvent);
    svgElement.addEventListener("pointerenter", handlePointerEvent);
    return () => {
      svgElement.removeEventListener("pointerdown", handlePointerEvent);
      svgElement.removeEventListener("pointermove", handlePointerEvent);
      svgElement.removeEventListener("pointerenter", handlePointerEvent);
      pointerUpdate.clear();
    };
  }, [svgRef, positionRef, itemPosition]);
  const anchorEl = React28.useMemo(() => ({
    getBoundingClientRect: () => ({
      x: positionRef.current.x,
      y: positionRef.current.y,
      top: positionRef.current.y,
      left: positionRef.current.x,
      right: positionRef.current.x,
      bottom: positionRef.current.y,
      width: 0,
      height: 0,
      toJSON: () => ""
    })
  }), [positionRef]);
  const isMouse = pointerType?.pointerType === "mouse" || isFineMainPointer;
  const isTouch = pointerType?.pointerType === "touch" || !isFineMainPointer;
  const modifiers = React28.useMemo(() => [
    {
      name: "offset",
      options: {
        offset: () => {
          if (isTouch) {
            return [0, 64];
          }
          return [0, 8];
        }
      }
    },
    ...!isMouse ? [{
      name: "flip",
      options: {
        fallbackPlacements: ["top-end", "top-start", "bottom-end", "bottom"]
      }
    }] : [],
    // Keep default behavior
    {
      name: "preventOverflow",
      options: {
        altAxis: true
      }
    }
  ], [isMouse, isTouch]);
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime24.jsx)(NoSsr_default, {
    children: isOpen && (0, import_jsx_runtime24.jsx)(ChartsTooltipRoot, _extends({}, other, {
      className: classes?.root,
      open: isOpen,
      placement: other.placement ?? position ?? (isMouse ? "right-start" : "top"),
      popperRef,
      anchorEl,
      modifiers,
      children
    }))
  });
}
true ? ChartsTooltipContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Determine if the tooltip should be placed on the pointer location or on the node.
   * @default 'pointer'
   */
  anchor: import_prop_types16.default.oneOf(["node", "pointer"]),
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types16.default.oneOfType([HTMLElementType, import_prop_types16.default.object, import_prop_types16.default.func]),
  /**
   * Popper render function or node.
   */
  children: import_prop_types16.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types16.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types16.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types16.default.shape({
    Root: import_prop_types16.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types16.default.shape({
    root: import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types16.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types16.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types16.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types16.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types16.default.arrayOf(import_prop_types16.default.shape({
    data: import_prop_types16.default.object,
    effect: import_prop_types16.default.func,
    enabled: import_prop_types16.default.bool,
    fn: import_prop_types16.default.func,
    name: import_prop_types16.default.any,
    options: import_prop_types16.default.object,
    phase: import_prop_types16.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types16.default.arrayOf(import_prop_types16.default.string),
    requiresIfExists: import_prop_types16.default.arrayOf(import_prop_types16.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types16.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types16.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types16.default.shape({
    modifiers: import_prop_types16.default.array,
    onFirstUpdate: import_prop_types16.default.func,
    placement: import_prop_types16.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types16.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.shape({
    current: import_prop_types16.default.shape({
      destroy: import_prop_types16.default.func.isRequired,
      forceUpdate: import_prop_types16.default.func.isRequired,
      setOptions: import_prop_types16.default.func.isRequired,
      state: import_prop_types16.default.shape({
        attributes: import_prop_types16.default.object.isRequired,
        elements: import_prop_types16.default.object.isRequired,
        modifiersData: import_prop_types16.default.object.isRequired,
        options: import_prop_types16.default.object.isRequired,
        orderedModifiers: import_prop_types16.default.arrayOf(import_prop_types16.default.object).isRequired,
        placement: import_prop_types16.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types16.default.object.isRequired,
        reset: import_prop_types16.default.bool.isRequired,
        scrollParents: import_prop_types16.default.object.isRequired,
        strategy: import_prop_types16.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types16.default.object.isRequired
      }).isRequired,
      update: import_prop_types16.default.func.isRequired
    })
  })]),
  /**
   * Determines the tooltip position relatively to the anchor.
   */
  position: import_prop_types16.default.oneOf(["bottom", "left", "right", "top"]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types16.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types16.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object, import_prop_types16.default.bool])), import_prop_types16.default.func, import_prop_types16.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types16.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse;
   * - 'axis': Shows values associated with the hovered x value;
   * - 'none': Does not display tooltip.
   * @default 'axis'
   */
  trigger: import_prop_types16.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function ChartsTooltip(props) {
  const {
    classes: propClasses,
    trigger = "axis"
  } = props;
  const classes = useUtilityClasses7(propClasses);
  return (0, import_jsx_runtime25.jsx)(ChartsTooltipContainer, _extends({}, props, {
    classes: propClasses,
    children: trigger === "axis" ? (0, import_jsx_runtime25.jsx)(ChartsAxisTooltipContent, {
      classes
    }) : (0, import_jsx_runtime25.jsx)(ChartsItemTooltipContent, {
      classes
    })
  }));
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Determine if the tooltip should be placed on the pointer location or on the node.
   * @default 'pointer'
   */
  anchor: import_prop_types17.default.oneOf(["node", "pointer"]),
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types17.default.oneOfType([HTMLElementType, import_prop_types17.default.object, import_prop_types17.default.func]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types17.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types17.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types17.default.shape({
    Root: import_prop_types17.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types17.default.shape({
    root: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types17.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types17.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types17.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types17.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types17.default.arrayOf(import_prop_types17.default.shape({
    data: import_prop_types17.default.object,
    effect: import_prop_types17.default.func,
    enabled: import_prop_types17.default.bool,
    fn: import_prop_types17.default.func,
    name: import_prop_types17.default.any,
    options: import_prop_types17.default.object,
    phase: import_prop_types17.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types17.default.arrayOf(import_prop_types17.default.string),
    requiresIfExists: import_prop_types17.default.arrayOf(import_prop_types17.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types17.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types17.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types17.default.shape({
    modifiers: import_prop_types17.default.array,
    onFirstUpdate: import_prop_types17.default.func,
    placement: import_prop_types17.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types17.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.shape({
    current: import_prop_types17.default.shape({
      destroy: import_prop_types17.default.func.isRequired,
      forceUpdate: import_prop_types17.default.func.isRequired,
      setOptions: import_prop_types17.default.func.isRequired,
      state: import_prop_types17.default.shape({
        attributes: import_prop_types17.default.object.isRequired,
        elements: import_prop_types17.default.object.isRequired,
        modifiersData: import_prop_types17.default.object.isRequired,
        options: import_prop_types17.default.object.isRequired,
        orderedModifiers: import_prop_types17.default.arrayOf(import_prop_types17.default.object).isRequired,
        placement: import_prop_types17.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types17.default.object.isRequired,
        reset: import_prop_types17.default.bool.isRequired,
        scrollParents: import_prop_types17.default.object.isRequired,
        strategy: import_prop_types17.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types17.default.object.isRequired
      }).isRequired,
      update: import_prop_types17.default.func.isRequired
    })
  })]),
  /**
   * Determines the tooltip position relatively to the anchor.
   */
  position: import_prop_types17.default.oneOf(["bottom", "left", "right", "top"]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types17.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types17.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object, import_prop_types17.default.bool])), import_prop_types17.default.func, import_prop_types17.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types17.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse;
   * - 'axis': Shows values associated with the hovered x value;
   * - 'none': Does not display tooltip.
   * @default 'axis'
   */
  trigger: import_prop_types17.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var React31 = __toESM(require_react(), 1);
var import_prop_types19 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/onClickContextBuilder.js
var seriesContextBuilder = (context) => ({
  type: "series",
  color: context.color,
  label: context.label,
  seriesId: context.seriesId,
  itemId: context.itemId
});

// node_modules/@mui/x-charts/esm/ChartsLegend/chartsLegendClasses.js
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var useUtilityClasses10 = (props) => {
  const {
    classes,
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    item: ["item"],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "item", "series", "mark", "label", "vertical", "horizontal"]);

// node_modules/@mui/x-charts/esm/internals/consumeSlots.js
var React29 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var _excluded13 = ["slots", "slotProps"];
var _excluded25 = ["ownerState"];
var consumeSlots = (name, slotPropName, options, InComponent) => {
  function ConsumeSlotsInternal(props, ref) {
    const themedProps = useThemeProps({
      props,
      // eslint-disable-next-line material-ui/mui-name-matches-component-name
      name
    });
    const defaultProps3 = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
    const defaultizedProps = resolveProps(defaultProps3, themedProps);
    const _ref = defaultizedProps, {
      slots,
      slotProps
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded13);
    const theme = useTheme();
    const classes = options.classesResolver?.(defaultizedProps, theme);
    const Component = slots?.[slotPropName] ?? InComponent;
    const propagateSlots = options.propagateSlots && !slots?.[slotPropName];
    const _useSlotProps = useSlotProps_default({
      elementType: Component,
      externalSlotProps: slotProps?.[slotPropName],
      additionalProps: _extends({}, other, {
        classes
      }, propagateSlots && {
        slots,
        slotProps
      }),
      ownerState: {}
    }), originalOutProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded25);
    const outProps = _extends({}, originalOutProps);
    for (const prop of options.omitProps ?? []) {
      delete outProps[prop];
    }
    if (true) {
      Component.displayName = `${name}.slots.${slotPropName}`;
    }
    return (0, import_jsx_runtime26.jsx)(Component, _extends({}, outProps, {
      ref
    }));
  }
  return React29.forwardRef(ConsumeSlotsInternal);
};
if (true) consumeSlots.displayName = "consumeSlots";

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabel.js
var React30 = __toESM(require_react(), 1);
var import_prop_types18 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelClasses.js
function getLabelUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabel", slot);
}
var labelClasses = generateUtilityClasses("MuiChartsLabel", ["root"]);
var useUtilityClasses11 = (props) => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getLabelUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabel.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var _excluded14 = ["children", "className", "classes"];
var ChartsLabel = consumeThemeProps("MuiChartsLabel", {
  classesResolver: useUtilityClasses11
}, function ChartsLabel2(props, ref) {
  const {
    children,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  return (0, import_jsx_runtime27.jsx)("span", _extends({
    className: clsx_default(classes?.root, className),
    ref
  }, other, {
    children
  }));
});
true ? ChartsLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types18.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types18.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var _excluded15 = ["direction", "onItemClick", "className", "classes"];
var RootElement = styled_default("ul", {
  name: "MuiChartsLegend",
  slot: "Root"
})(({
  ownerState,
  theme
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "flex",
  flexDirection: ownerState.direction === "vertical" ? "column" : "row",
  alignItems: ownerState.direction === "vertical" ? void 0 : "center",
  flexShrink: 0,
  gap: theme.spacing(2),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  flexWrap: "wrap",
  li: {
    display: ownerState.direction === "horizontal" ? "inline-flex" : void 0
  },
  [`button.${legendClasses.series}`]: {
    // Reset button styles
    background: "none",
    border: "none",
    padding: 0,
    fontFamily: "inherit",
    fontWeight: "inherit",
    fontSize: "inherit",
    letterSpacing: "inherit",
    color: "inherit"
  },
  [`& .${legendClasses.series}`]: {
    display: ownerState.direction === "vertical" ? "flex" : "inline-flex",
    alignItems: "center",
    gap: theme.spacing(1)
  },
  gridArea: "legend"
}));
var ChartsLegend = consumeSlots("MuiChartsLegend", "legend", {
  defaultProps: {
    direction: "horizontal"
  },
  // @ts-expect-error position is used only in the slots, but it is passed to the SVG wrapper.
  // We omit it here to avoid passing to slots.
  omitProps: ["position"],
  classesResolver: useUtilityClasses10
}, React31.forwardRef(function ChartsLegend2(props, ref) {
  const data = useLegend();
  const {
    onItemClick,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  if (data.items.length === 0) {
    return null;
  }
  const Element2 = onItemClick ? "button" : "div";
  return (0, import_jsx_runtime28.jsx)(RootElement, _extends({
    className: clsx_default(classes?.root, className),
    ref
  }, other, {
    ownerState: props,
    children: data.items.map((item, i) => {
      return (0, import_jsx_runtime28.jsx)("li", {
        className: classes?.item,
        "data-series": item.id,
        children: (0, import_jsx_runtime28.jsxs)(Element2, {
          className: classes?.series,
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: onItemClick ? (
            // @ts-ignore onClick is only attached to a button
            (event) => onItemClick(event, seriesContextBuilder(item), i)
          ) : void 0,
          children: [(0, import_jsx_runtime28.jsx)(ChartsLabelMark, {
            className: classes?.mark,
            color: item.color,
            type: item.markType
          }), (0, import_jsx_runtime28.jsx)(ChartsLabel, {
            className: classes?.label,
            children: item.label
          })]
        })
      }, item.id);
    })
  }));
}));
if (true) ChartsLegend.displayName = "ChartsLegend";
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types19.default.object,
  className: import_prop_types19.default.string,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types19.default.oneOf(["horizontal", "vertical"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types19.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types19.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types19.default.object,
  sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var React33 = __toESM(require_react(), 1);
var import_prop_types21 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/useAxis.js
function useAxis({
  axisDirection,
  axisId
}) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  switch (axisDirection) {
    case "x": {
      const id = typeof axisId === "string" ? axisId : xAxisIds[axisId ?? 0];
      return xAxis[id];
    }
    case "y": {
      const id = typeof axisId === "string" ? axisId : yAxisIds[axisId ?? 0];
      return yAxis[id];
    }
    case "z":
    default: {
      const id = typeof axisId === "string" ? axisId : zAxisIds[axisId ?? 0];
      return zAxis[id];
    }
  }
}

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelGradient.js
var React32 = __toESM(require_react(), 1);
var import_prop_types20 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelGradientClasses.js
function getLabelGradientUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelGradient", slot);
}
var labelGradientClasses = generateUtilityClasses("MuiChartsLabelGradient", ["root", "vertical", "horizontal", "mask", "fill"]);
var useUtilityClasses12 = (props) => {
  const {
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelGradientUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelGradient.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var _excluded16 = ["gradientId", "direction", "classes", "className", "rotate", "reverse", "thickness"];
var getRotation = (direction, reverse, rotate, isRtl) => {
  const angle = (direction === "vertical" ? -90 : 0) + (rotate ? 90 : 0) + (reverse ? 180 : 0);
  if (isRtl && direction !== "vertical") {
    return angle + 180;
  }
  return angle;
};
var Root2 = styled_default("div", {
  name: "MuiChartsLabelGradient",
  slot: "Root"
})(({
  ownerState
}) => {
  const rotation = getRotation(ownerState.direction, ownerState.reverse, ownerState.rotate, ownerState.isRtl);
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    [`.${labelGradientClasses.mask}`]: {
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelGradientClasses.horizontal}`]: {
      width: "100%",
      [`.${labelGradientClasses.mask}`]: {
        height: ownerState.thickness,
        width: "100%"
      }
    },
    [`&.${labelGradientClasses.vertical}`]: {
      height: "100%",
      [`.${labelGradientClasses.mask}`]: {
        width: ownerState.thickness,
        height: "100%",
        "> svg": {
          height: "100%"
        }
      }
    },
    svg: {
      transform: `rotate(${rotation}deg)`,
      display: "block"
    }
  };
});
var ChartsLabelGradient = consumeThemeProps("MuiChartsLabelGradient", {
  defaultProps: {
    direction: "horizontal",
    thickness: 12
  },
  classesResolver: useUtilityClasses12
}, function ChartsLabelGradient2(props, ref) {
  const {
    gradientId,
    classes,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const isRtl = useRtl();
  return (0, import_jsx_runtime29.jsx)(Root2, _extends({
    className: clsx_default(classes?.root, className),
    ownerState: _extends({}, props, {
      isRtl
    }),
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime29.jsx)("div", {
      className: classes?.mask,
      children: (0, import_jsx_runtime29.jsx)("svg", {
        viewBox: "0 0 24 24",
        children: (0, import_jsx_runtime29.jsx)("rect", {
          className: classes?.fill,
          width: "24",
          height: "24",
          fill: `url(#${gradientId})`
        })
      })
    })
  }));
});
true ? ChartsLabelGradient.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types20.default.object,
  /**
   * The direction of the gradient.
   * @default 'horizontal'
   */
  direction: import_prop_types20.default.oneOf(["vertical", "horizontal"]),
  /**
   * A unique identifier for the gradient.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   */
  gradientId: import_prop_types20.default.string.isRequired,
  /**
   * If `true`, the gradient will be reversed.
   */
  reverse: import_prop_types20.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotate: import_prop_types20.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types20.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/continuousColorLegendClasses.js
function getLegendUtilityClass2(slot) {
  return generateUtilityClass("MuiContinuousColorLegend", slot);
}
var useUtilityClasses13 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    gradient: ["gradient"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass2, classes);
};
var continuousColorLegendClasses = generateUtilityClasses("MuiContinuousColorLegend", ["root", "minLabel", "maxLabel", "gradient", "vertical", "horizontal", "start", "end", "extremes", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var _excluded17 = ["minLabel", "maxLabel", "direction", "axisDirection", "axisId", "rotateGradient", "reverse", "classes", "className", "gradientId", "labelPosition", "thickness"];
var templateAreas = (reverse) => {
  const startLabel = reverse ? "max-label" : "min-label";
  const endLabel = reverse ? "min-label" : "max-label";
  return {
    row: {
      start: `
    '${startLabel} . ${endLabel}'
    'gradient gradient gradient'
  `,
      end: `
      'gradient gradient gradient'
      '${startLabel} . ${endLabel}'
    `,
      extremes: `
      '${startLabel} gradient ${endLabel}'
    `
    },
    column: {
      start: `
      '${endLabel} gradient'
      '. gradient'
      '${startLabel} gradient'
    `,
      end: `
      'gradient ${endLabel}'
      'gradient .'
      'gradient ${startLabel}'
    `,
      extremes: `
      '${endLabel}'
      'gradient'
      '${startLabel}'
    `
    }
  };
};
var RootElement2 = styled_default("ul", {
  name: "MuiContinuousColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "grid",
  flexShrink: 0,
  gap: theme.spacing(0.5),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  gridArea: "legend",
  [`&.${continuousColorLegendClasses.horizontal}`]: {
    gridTemplateRows: "min-content min-content",
    gridTemplateColumns: "min-content auto min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.start
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.end
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.extremes,
      gridTemplateRows: "min-content",
      alignItems: "center"
    }
  },
  [`&.${continuousColorLegendClasses.vertical}`]: {
    gridTemplateRows: "min-content auto min-content",
    gridTemplateColumns: "min-content min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.start,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "end"
      }
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.end,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "start"
      }
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.extremes,
      gridTemplateColumns: "min-content",
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "center"
      }
    }
  },
  [`.${continuousColorLegendClasses.gradient}`]: {
    gridArea: "gradient"
  },
  [`.${continuousColorLegendClasses.maxLabel}`]: {
    gridArea: "max-label"
  },
  [`.${continuousColorLegendClasses.minLabel}`]: {
    gridArea: "min-label"
  }
}));
var getText = (label, value, formattedValue) => {
  if (typeof label === "string") {
    return label;
  }
  return label?.({
    value,
    formattedValue
  }) ?? formattedValue;
};
var isZAxis = (axis) => axis.scale === void 0;
var ContinuousColorLegend = consumeThemeProps("MuiContinuousColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "end",
    axisDirection: "z"
  },
  classesResolver: useUtilityClasses13
}, function ContinuousColorLegend2(props, ref) {
  const {
    minLabel,
    maxLabel,
    direction,
    axisDirection,
    axisId,
    rotateGradient,
    reverse,
    classes,
    className,
    gradientId,
    thickness
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
  const generateGradientId = useChartGradientIdObjectBoundBuilder();
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem?.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "continuous") {
    return null;
  }
  const minValue = colorMap.min ?? 0;
  const maxValue = colorMap.max ?? 100;
  const valueFormatter = isZAxis(axisItem) ? void 0 : axisItem.valueFormatter;
  const formattedMin = valueFormatter ? valueFormatter(minValue, {
    location: "legend"
  }) : minValue.toLocaleString();
  const formattedMax = valueFormatter ? valueFormatter(maxValue, {
    location: "legend"
  }) : maxValue.toLocaleString();
  const minText = getText(minLabel, minValue, formattedMin);
  const maxText = getText(maxLabel, maxValue, formattedMax);
  const minComponent = (0, import_jsx_runtime30.jsx)("li", {
    className: classes?.minLabel,
    children: (0, import_jsx_runtime30.jsx)(ChartsLabel, {
      className: classes?.label,
      children: minText
    })
  });
  const maxComponent = (0, import_jsx_runtime30.jsx)("li", {
    className: classes?.maxLabel,
    children: (0, import_jsx_runtime30.jsx)(ChartsLabel, {
      className: classes?.label,
      children: maxText
    })
  });
  return (0, import_jsx_runtime30.jsxs)(RootElement2, _extends({
    className: clsx_default(classes?.root, className),
    ref
  }, other, {
    ownerState: props,
    children: [reverse ? maxComponent : minComponent, (0, import_jsx_runtime30.jsx)("li", {
      className: classes?.gradient,
      children: (0, import_jsx_runtime30.jsx)(ChartsLabelGradient, {
        direction,
        rotate: rotateGradient,
        reverse,
        thickness,
        gradientId: gradientId ?? generateGradientId(axisItem.id)
      })
    }), reverse ? minComponent : maxComponent]
  }));
});
true ? ContinuousColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types21.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types21.default.oneOfType([import_prop_types21.default.number, import_prop_types21.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types21.default.object,
  className: import_prop_types21.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types21.default.oneOf(["horizontal", "vertical"]),
  /**
   * The id for the gradient to use.
   * If not provided, it will use the generated gradient from the axis configuration.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   * @default auto-generated id
   */
  gradientId: import_prop_types21.default.string,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'end'
   */
  labelPosition: import_prop_types21.default.oneOf(["start", "end", "extremes"]),
  /**
   * The label to display at the maximum side of the gradient.
   * Can either be a string, or a function.
   * If not defined, the formatted maximal value is display.
   * @default formattedValue
   */
  maxLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.string]),
  /**
   * The label to display at the minimum side of the gradient.
   * Can either be a string, or a function.
   * @default formattedValue
   */
  minLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.string]),
  /**
   * If `true`, the gradient and labels will be reversed.
   * @default false
   */
  reverse: import_prop_types21.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotateGradient: import_prop_types21.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types21.default.number,
  sx: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object, import_prop_types21.default.bool])), import_prop_types21.default.func, import_prop_types21.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var React34 = __toESM(require_react(), 1);
var import_prop_types22 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorLegendClasses.js
function getLegendUtilityClass3(slot) {
  return generateUtilityClass("MuiPiecewiseColorLegendClasses", slot);
}
var useUtilityClasses14 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition?.replaceAll(/-(\w)/g, (match) => match[1].toUpperCase())],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    item: ["item"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass3, classes);
};
var piecewiseColorLegendClasses = generateUtilityClasses("MuiPiecewiseColorLegendClasses", ["root", "minLabel", "maxLabel", "item", "vertical", "horizontal", "start", "end", "extremes", "inlineStart", "inlineEnd", "mark", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorDefaultLabelFormatter.js
function piecewiseColorDefaultLabelFormatter(params) {
  if (params.min === null) {
    return `<${params.formattedMax}`;
  }
  if (params.max === null) {
    return `>${params.formattedMin}`;
  }
  return `${params.formattedMin}-${params.formattedMax}`;
}

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var _excluded18 = ["direction", "classes", "className", "markType", "labelPosition", "axisDirection", "axisId", "labelFormatter", "onItemClick"];
var RootElement3 = styled_default("ul", {
  name: "MuiPiecewiseColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => {
  const classes = piecewiseColorLegendClasses;
  return _extends({}, theme.typography.caption, {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: "100%",
    display: "flex",
    flexDirection: ownerState.direction === "vertical" ? "column" : "row",
    flexShrink: 0,
    gap: theme.spacing(0.5),
    listStyleType: "none",
    paddingInlineStart: 0,
    marginBlock: theme.spacing(1),
    marginInline: theme.spacing(1),
    width: "fit-content",
    gridArea: "legend",
    [`button.${classes.item}`]: {
      // Reset button styles
      background: "none",
      border: "none",
      padding: 0,
      cursor: ownerState.onItemClick ? "pointer" : "unset",
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      letterSpacing: "inherit",
      color: "inherit"
    },
    [`.${classes.item}`]: {
      display: "flex",
      gap: theme.spacing(0.5)
    },
    [`li :not(.${classes.minLabel}, .${classes.maxLabel}) .${classes?.mark}`]: {
      alignSelf: "center"
    },
    [`&.${classes.start}`]: {
      alignItems: "end"
    },
    [`&.${classes.end}`]: {
      alignItems: "start"
    },
    [`&.${classes.horizontal}`]: {
      alignItems: "center",
      [`.${classes.item}`]: {
        flexDirection: "column"
      },
      [`&.${classes.inlineStart}, &.${classes.inlineEnd}`]: {
        gap: theme.spacing(1.5),
        flexWrap: "wrap",
        [`.${classes.item}`]: {
          flexDirection: "row"
        }
      },
      [`&.${classes.start}`]: {
        alignItems: "end"
      },
      [`&.${classes.end}`]: {
        alignItems: "start"
      },
      [`.${classes.minLabel}`]: {
        alignItems: "end"
      },
      [`&.${classes.extremes}`]: {
        [`.${classes.minLabel}, .${classes.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "row"
        }
      }
    },
    [`&.${classes.vertical}`]: {
      [`.${classes.item}`]: {
        flexDirection: "row",
        alignItems: "center"
      },
      [`&.${classes.start}, &.${classes.inlineStart}`]: {
        alignItems: "end"
      },
      [`&.${classes.end}, &.${classes.inlineEnd}`]: {
        alignItems: "start"
      },
      [`&.${classes.extremes}`]: {
        alignItems: "center",
        [`.${classes.minLabel}, .${classes.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "column"
        }
      }
    }
  });
});
var PiecewiseColorLegend = consumeThemeProps("MuiPiecewiseColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "extremes",
    labelFormatter: piecewiseColorDefaultLabelFormatter
  },
  classesResolver: useUtilityClasses14
}, function PiecewiseColorLegend2(props, ref) {
  const {
    direction,
    classes,
    className,
    markType,
    labelPosition,
    axisDirection,
    axisId,
    labelFormatter,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
  const isVertical = direction === "vertical";
  const isReverse = isVertical;
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem?.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "piecewise") {
    return null;
  }
  const valueFormatter = (v) => axisItem.valueFormatter?.(v, {
    location: "legend"
  }) ?? v.toLocaleString();
  const formattedLabels = colorMap.thresholds.map(valueFormatter);
  const startClass = isReverse ? classes?.maxLabel : classes?.minLabel;
  const endClass = isReverse ? classes?.minLabel : classes?.maxLabel;
  const colors = colorMap.colors.map((color, colorIndex) => ({
    color,
    colorIndex
  }));
  const orderedColors = isReverse ? colors.reverse() : colors;
  const isStart = labelPosition === "start";
  const isEnd = labelPosition === "end";
  const isExtremes = labelPosition === "extremes";
  const isInlineStart = labelPosition === "inline-start";
  const isInlineEnd = labelPosition === "inline-end";
  return (0, import_jsx_runtime31.jsx)(RootElement3, _extends({
    className: clsx_default(classes?.root, className),
    ref
  }, other, {
    ownerState: props,
    children: orderedColors.map(({
      color,
      colorIndex
    }, index) => {
      const isFirst = index === 0;
      const isLast = index === colorMap.colors.length - 1;
      const isFirstColor = colorIndex === 0;
      const isLastColor = colorIndex === colorMap.colors.length - 1;
      const data = _extends({
        index: colorIndex,
        length: formattedLabels.length
      }, isFirstColor ? {
        min: null,
        formattedMin: null
      } : {
        min: colorMap.thresholds[colorIndex - 1],
        formattedMin: formattedLabels[colorIndex - 1]
      }, isLastColor ? {
        max: null,
        formattedMax: null
      } : {
        max: colorMap.thresholds[colorIndex],
        formattedMax: formattedLabels[colorIndex]
      });
      const label = labelFormatter?.(data);
      if (label === null || label === void 0) {
        return null;
      }
      const isTextBefore = isStart || isExtremes && isFirst || isInlineStart;
      const isTextAfter = isEnd || isExtremes && isLast || isInlineEnd;
      const clickObject = {
        type: "piecewiseColor",
        color,
        label,
        minValue: data.min,
        maxValue: data.max
      };
      const Element2 = onItemClick ? "button" : "div";
      return (0, import_jsx_runtime31.jsx)("li", {
        children: (0, import_jsx_runtime31.jsxs)(Element2, {
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: (
            // @ts-ignore onClick is only attached to a button
            onItemClick ? (event) => onItemClick(event, clickObject, index) : void 0
          ),
          className: clsx_default(classes?.item, index === 0 && `${startClass}`, index === orderedColors.length - 1 && `${endClass}`),
          children: [isTextBefore && (0, import_jsx_runtime31.jsx)(ChartsLabel, {
            className: classes?.label,
            children: label
          }), (0, import_jsx_runtime31.jsx)(ChartsLabelMark, {
            className: classes?.mark,
            type: markType,
            color
          }), isTextAfter && (0, import_jsx_runtime31.jsx)(ChartsLabel, {
            className: classes?.label,
            children: label
          })]
        })
      }, colorIndex);
    })
  }));
});
true ? PiecewiseColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types22.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types22.default.object,
  className: import_prop_types22.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types22.default.oneOf(["horizontal", "vertical"]),
  /**
   * Format the legend labels.
   * @param {PiecewiseLabelFormatterParams} params The bound of the piece to format.
   * @returns {string|null} The displayed label, `''` to skip the label but show the color mark, or `null` to skip it entirely.
   */
  labelFormatter: import_prop_types22.default.func,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'extremes'
   */
  labelPosition: import_prop_types22.default.oneOf(["start", "end", "extremes", "inline-start", "inline-end"]),
  /**
   * The type of the mark.
   * @default 'square'
   */
  markType: import_prop_types22.default.oneOf(["square", "circle", "line"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {PiecewiseColorLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types22.default.func,
  sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var React37 = __toESM(require_react(), 1);
var import_prop_types23 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/chartsAxisHighlightClasses.js
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var React35 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlightPath.js
var ChartsAxisHighlightPath = styled_default("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  variants: [{
    props: {
      axisHighlight: "band"
    },
    style: _extends({
      fill: "white",
      fillOpacity: 0.1
    }, theme.applyStyles("light", {
      fill: "gray"
    }))
  }, {
    props: {
      axisHighlight: "line"
    },
    style: _extends({
      strokeDasharray: "5 2",
      stroke: "#ffffff"
    }, theme.applyStyles("light", {
      stroke: "#000000"
    }))
  }]
}));

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
function ChartsYHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    left: left2,
    width
  } = useDrawingArea();
  const store = useStore();
  const axisYValues = store.use(selectorChartsHighlightYAxisValue);
  const yAxes = store.use(selectorChartYAxis);
  if (axisYValues.length === 0) {
    return null;
  }
  return axisYValues.map(({
    axisId,
    value
  }) => {
    const yAxis = yAxes.axis[axisId];
    const yScale = yAxis.scale;
    const getYPosition = getValueToPositionMapper(yScale);
    const isYScaleOrdinal = type === "band" && value !== null && isOrdinalScale(yScale);
    if (true) {
      const isError = isYScaleOrdinal && yScale(value) === void 0;
      if (isError) {
        console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
      }
    }
    return (0, import_jsx_runtime32.jsxs)(React35.Fragment, {
      children: [isYScaleOrdinal && yScale(value) !== void 0 && (0, import_jsx_runtime32.jsx)(ChartsAxisHighlightPath, {
        d: `M ${left2} ${yScale(value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${width} 0 l 0 ${-yScale.step()} Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }), type === "line" && value !== null && (0, import_jsx_runtime32.jsx)(ChartsAxisHighlightPath, {
        d: `M ${left2} ${getYPosition(value)} L ${left2 + width} ${getYPosition(value)}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      })]
    }, `${axisId}-${value}`);
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsXAxisHighlight.js
var React36 = __toESM(require_react(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function ChartsXHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    top: top2,
    height
  } = useDrawingArea();
  const store = useStore();
  const axisXValues = store.use(selectorChartsHighlightXAxisValue);
  const xAxes = store.use(selectorChartXAxis);
  if (axisXValues.length === 0) {
    return null;
  }
  return axisXValues.map(({
    axisId,
    value
  }) => {
    const xAxis = xAxes.axis[axisId];
    const xScale = xAxis.scale;
    const getXPosition = getValueToPositionMapper(xScale);
    const isXScaleOrdinal = type === "band" && value !== null && isOrdinalScale(xScale);
    if (true) {
      const isError = isXScaleOrdinal && xScale(value) === void 0;
      if (isError) {
        console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
      }
    }
    return (0, import_jsx_runtime33.jsxs)(React36.Fragment, {
      children: [isXScaleOrdinal && xScale(value) !== void 0 && (0, import_jsx_runtime33.jsx)(ChartsAxisHighlightPath, {
        d: `M ${xScale(value) - (xScale.step() - xScale.bandwidth()) / 2} ${top2} l ${xScale.step()} 0 l 0 ${height} l ${-xScale.step()} 0 Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }), type === "line" && value !== null && (0, import_jsx_runtime33.jsx)(ChartsAxisHighlightPath, {
        d: `M ${getXPosition(value)} ${top2} L ${getXPosition(value)} ${top2 + height}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      })]
    }, `${axisId}-${value}`);
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses15 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const classes = useUtilityClasses15();
  return (0, import_jsx_runtime34.jsxs)(React37.Fragment, {
    children: [xAxisHighlight && xAxisHighlight !== "none" && (0, import_jsx_runtime34.jsx)(ChartsXHighlight, {
      type: xAxisHighlight,
      classes
    }), yAxisHighlight && yAxisHighlight !== "none" && (0, import_jsx_runtime34.jsx)(ChartsYHighlight, {
      type: yAxisHighlight,
      classes
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types23.default.oneOf(["band", "line", "none"]),
  y: import_prop_types23.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsClipPath/ChartsClipPath.js
var import_prop_types24 = __toESM(require_prop_types(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left: left2,
    top: top2,
    width,
    height
  } = useDrawingArea();
  const offset2 = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime35.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime35.jsx)("rect", {
      x: left2 - offset2.left,
      y: top2 - offset2.top,
      width: width + offset2.left + offset2.right,
      height: height + offset2.top + offset2.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the clip path.
   */
  id: import_prop_types24.default.string.isRequired,
  /**
   * Offset, in pixels, of the clip path rectangle from the drawing area.
   *
   * A positive value will move the rectangle outside the drawing area.
   */
  offset: import_prop_types24.default.shape({
    bottom: import_prop_types24.default.number,
    left: import_prop_types24.default.number,
    right: import_prop_types24.default.number,
    top: import_prop_types24.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var import_prop_types25 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsGrid/chartsGridClasses.js
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/esm/ChartsGrid/styledComponents.js
var GridRoot = styled_default("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default("line", {
  name: "MuiChartsGrid",
  slot: "Line"
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsVerticalGrid.js
var React38 = __toESM(require_react(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function ChartsGridVertical(props) {
  const {
    instance
  } = useChartContext();
  const {
    axis,
    start: start2,
    end: end2,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval,
    tickSpacing
  } = axis;
  const xTicks = useTicks({
    scale,
    tickNumber,
    tickInterval,
    tickSpacing,
    direction: "x",
    ordinalTimeTicks: "ordinalTimeTicks" in axis ? axis.ordinalTimeTicks : void 0
  });
  return (0, import_jsx_runtime36.jsx)(React38.Fragment, {
    children: xTicks.map(({
      value,
      offset: offset2
    }) => !instance.isXInside(offset2) ? null : (0, import_jsx_runtime36.jsx)(GridLine, {
      y1: start2,
      y2: end2,
      x1: offset2,
      x2: offset2,
      className: classes.verticalLine
    }, `vertical-${value?.getTime?.() ?? value}`))
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsHorizontalGrid.js
var React39 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
function ChartsGridHorizontal(props) {
  const {
    instance
  } = useChartContext();
  const {
    axis,
    start: start2,
    end: end2,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval,
    tickSpacing
  } = axis;
  const yTicks = useTicks({
    scale,
    tickNumber,
    tickInterval,
    tickSpacing,
    direction: "y",
    ordinalTimeTicks: "ordinalTimeTicks" in axis ? axis.ordinalTimeTicks : void 0
  });
  return (0, import_jsx_runtime37.jsx)(React39.Fragment, {
    children: yTicks.map(({
      value,
      offset: offset2
    }) => !instance.isYInside(offset2) ? null : (0, import_jsx_runtime37.jsx)(GridLine, {
      y1: offset2,
      y2: offset2,
      x1: start2,
      x2: end2,
      className: classes.horizontalLine
    }, `horizontal-${value?.getTime?.() ?? value}`))
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var _excluded19 = ["vertical", "horizontal"];
var useUtilityClasses16 = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsGrid"
  });
  const drawingArea = useDrawingArea();
  const {
    vertical,
    horizontal
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const classes = useUtilityClasses16(props);
  const horizontalAxis = yAxis[yAxisIds[0]];
  const verticalAxis = xAxis[xAxisIds[0]];
  return (0, import_jsx_runtime38.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && (0, import_jsx_runtime38.jsx)(ChartsGridVertical, {
      axis: verticalAxis,
      start: drawingArea.top,
      end: drawingArea.height + drawingArea.top,
      classes
    }), horizontal && (0, import_jsx_runtime38.jsx)(ChartsGridHorizontal, {
      axis: horizontalAxis,
      start: drawingArea.left,
      end: drawingArea.width + drawingArea.left,
      classes
    })]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types25.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types25.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types25.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var React40 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsLoadingOverlay.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var _excluded20 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  const {
    top: top2,
    left: left2,
    height,
    width
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime39.jsx)(StyledText, _extends({
    x: left2 + width / 2,
    y: top2 + height / 2
  }, other, {
    children: message ?? localeText.loading
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsNoDataOverlay.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var _excluded21 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
  const {
    top: top2,
    left: left2,
    height,
    width
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime40.jsx)(StyledText2, _extends({
    x: left2 + width / 2,
    y: top2 + height / 2
  }, other, {
    children: message ?? localeText.noData
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => {
      const seriesItem = series[seriesId];
      if (seriesItem.type === "sankey") {
        return seriesItem.data.links.length === 0;
      }
      return seriesItem.data.length === 0;
    });
  });
}
function ChartsOverlay(props) {
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = props.slots?.loadingOverlay ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime41.jsx)(LoadingOverlay, _extends({}, props.slotProps?.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = props.slots?.noDataOverlay ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime41.jsx)(NoDataOverlay, _extends({}, props.slotProps?.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js
var React41 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarChart.plugins.js
var BAR_CHART_PLUGINS = [useChartZAxis, useChartBrush, useChartTooltip, useChartInteraction, useChartCartesianAxis, useChartHighlight, useChartKeyboardNavigation];

// node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js
var _excluded26 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "axisHighlight", "grid", "children", "slots", "slotProps", "skipAnimation", "loading", "layout", "onItemClick", "highlightedItem", "onHighlightChange", "borderRadius", "barLabel", "className", "hideLegend", "showToolbar", "brushConfig"];
var useBarChartProps = (props) => {
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    axisHighlight,
    grid,
    children,
    slots,
    slotProps,
    skipAnimation,
    loading,
    layout,
    onItemClick,
    highlightedItem,
    onHighlightChange,
    borderRadius,
    barLabel,
    className,
    brushConfig
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded26);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const hasHorizontalSeries = layout === "horizontal" || layout === void 0 && series.some((item) => item.layout === "horizontal");
  const defaultBandXAxis = React41.useMemo(() => [{
    id: DEFAULT_X_AXIS_KEY,
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
    }, (_, index) => index)
  }], [dataset, series]);
  const defaultBandYAxis = React41.useMemo(() => [{
    id: DEFAULT_Y_AXIS_KEY,
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
    }, (_, index) => index)
  }], [dataset, series]);
  const seriesWithDefault = React41.useMemo(() => series.map((s) => _extends({
    type: "bar"
  }, s, {
    layout: hasHorizontalSeries ? "horizontal" : "vertical"
  })), [hasHorizontalSeries, series]);
  const defaultXAxis = hasHorizontalSeries ? void 0 : defaultBandXAxis;
  const processedXAxis = React41.useMemo(() => {
    if (!xAxis) {
      return defaultXAxis;
    }
    return hasHorizontalSeries ? xAxis : xAxis.map((axis) => _extends({
      scaleType: "band"
    }, axis));
  }, [defaultXAxis, hasHorizontalSeries, xAxis]);
  const defaultYAxis = hasHorizontalSeries ? defaultBandYAxis : void 0;
  const processedYAxis = React41.useMemo(() => {
    if (!yAxis) {
      return defaultYAxis;
    }
    return hasHorizontalSeries ? yAxis.map((axis) => _extends({
      scaleType: "band"
    }, axis)) : yAxis;
  }, [defaultYAxis, hasHorizontalSeries, yAxis]);
  const chartContainerProps = _extends({}, other, {
    series: seriesWithDefault,
    width,
    height,
    margin,
    colors,
    dataset,
    xAxis: processedXAxis,
    yAxis: processedYAxis,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: slotProps?.tooltip?.trigger !== "axis" && axisHighlight?.x === "none" && axisHighlight?.y === "none",
    className,
    skipAnimation,
    brushConfig,
    plugins: BAR_CHART_PLUGINS
  });
  const barPlotProps = {
    onItemClick,
    slots,
    slotProps,
    borderRadius,
    barLabel
  };
  const gridProps = {
    vertical: grid?.vertical,
    horizontal: grid?.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({}, hasHorizontalSeries ? {
    y: "band"
  } : {
    x: "band"
  }, axisHighlight);
  const legendProps = {
    slots,
    slotProps
  };
  const chartsWrapperProps = {
    sx,
    legendPosition: props.slotProps?.legend?.position,
    legendDirection: props.slotProps?.legend?.direction,
    hideLegend: props.hideLegend ?? false
  };
  return {
    chartsWrapperProps,
    chartContainerProps,
    barPlotProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    children
  };
};

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var React44 = __toESM(require_react(), 1);
var import_prop_types26 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/material/index.js
var baseSlots = {
  baseButton: Button_default,
  baseIconButton: IconButton_default
};
var iconSlots = {};
var defaultSlotsMaterial = _extends({}, baseSlots, iconSlots);

// node_modules/@mui/x-charts/esm/context/ChartsSlotsContext.js
var React42 = __toESM(require_react(), 1);
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var ChartsSlotsContext = React42.createContext(null);
if (true) ChartsSlotsContext.displayName = "ChartsSlotsContext";
function useChartsSlots() {
  const context = React42.useContext(ChartsSlotsContext);
  if (context == null) {
    throw new Error(["MUI X Charts: Could not find the Charts Slots context.", "It looks like you rendered your component outside of a ChartDataProvider.", "This can also happen if you are bundling multiple versions of the library."].join("\n"));
  }
  return context;
}
function ChartsSlotsProvider(props) {
  const {
    slots,
    slotProps = {},
    defaultSlots,
    children
  } = props;
  const value = React42.useMemo(() => ({
    slots: _extends({}, defaultSlots, slots),
    slotProps
  }), [defaultSlots, slots, slotProps]);
  return (0, import_jsx_runtime42.jsx)(ChartsSlotsContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.js
var React43 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/findClosestPoints.js
function findClosestPoints(flatbush, seriesData, xScale, yScale, xZoomStart, xZoomEnd, yZoomStart, yZoomEnd, svgPointX, svgPointY, maxRadius = Infinity, maxResults = 1) {
  const originalXScale = xScale.copy();
  const originalYScale = yScale.copy();
  originalXScale.range([0, 1]);
  originalYScale.range([0, 1]);
  const excludeIfOutsideDrawingArea = function excludeIfOutsideDrawingArea2(index) {
    const x = originalXScale(seriesData[index].x);
    const y = originalYScale(seriesData[index].y);
    return x >= xZoomStart && x <= xZoomEnd && y >= yZoomStart && y <= yZoomEnd;
  };
  const fx = xScale.range()[1] - xScale.range()[0];
  const fy = yScale.range()[1] - yScale.range()[0];
  const fxSq = fx * fx;
  const fySq = fy * fy;
  function sqDistFn(dx, dy) {
    return fxSq * dx * dx + fySq * dy * dy;
  }
  const pointX = originalXScale(invertScale(xScale, svgPointX, (dataIndex) => seriesData[dataIndex]?.x));
  const pointY = originalYScale(invertScale(yScale, svgPointY, (dataIndex) => seriesData[dataIndex]?.y));
  return flatbush.neighbors(pointX, pointY, maxResults, maxRadius != null ? maxRadius * maxRadius : Infinity, excludeIfOutsideDrawingArea, sqDistFn);
}
function invertScale(scale, value, getDataPoint) {
  if (isOrdinalScale(scale)) {
    const dataIndex = scale.bandwidth() === 0 ? Math.floor((value - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((value - Math.min(...scale.range())) / scale.step());
    return getDataPoint(dataIndex);
  }
  return scale.invert(value);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.js
var useChartClosestPoint = ({
  svgRef,
  params,
  store,
  instance
}) => {
  const {
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick
  } = params;
  const {
    axis: xAxis,
    axisIds: xAxisIds
  } = store.use(selectorChartXAxis);
  const {
    axis: yAxis,
    axisIds: yAxisIds
  } = store.use(selectorChartYAxis);
  const zoomIsInteracting = store.use(selectorChartZoomIsInteracting);
  const {
    series,
    seriesOrder
  } = store.use(selectorChartSeriesProcessed)?.scatter ?? {};
  const flatbushMap = store.use(zoomIsInteracting ? selectorChartSeriesEmptyFlatbushMap : selectorChartSeriesFlatbushMap);
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  useEnhancedEffect_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: !disableVoronoi
    });
  }, [store, disableVoronoi]);
  React43.useEffect(() => {
    if (svgRef.current === null || disableVoronoi) {
      return void 0;
    }
    const element = svgRef.current;
    function getClosestPoint(event) {
      const svgPoint = getSVGPoint(element, event);
      if (!instance.isPointInside(svgPoint.x, svgPoint.y)) {
        return "outside-chart";
      }
      let closestPoint = void 0;
      for (const seriesId of seriesOrder ?? []) {
        const aSeries = (series ?? {})[seriesId];
        const flatbush = flatbushMap.get(seriesId);
        if (!flatbush) {
          continue;
        }
        const xAxisId = aSeries.xAxisId ?? defaultXAxisId;
        const yAxisId = aSeries.yAxisId ?? defaultYAxisId;
        const xAxisZoom = selectorChartAxisZoomData(store.state, xAxisId);
        const yAxisZoom = selectorChartAxisZoomData(store.state, yAxisId);
        const maxRadius = voronoiMaxRadius === "item" ? aSeries.markerSize : voronoiMaxRadius;
        const xZoomStart = (xAxisZoom?.start ?? 0) / 100;
        const xZoomEnd = (xAxisZoom?.end ?? 100) / 100;
        const yZoomStart = (yAxisZoom?.start ?? 0) / 100;
        const yZoomEnd = (yAxisZoom?.end ?? 100) / 100;
        const xScale = xAxis[xAxisId].scale;
        const yScale = yAxis[yAxisId].scale;
        const closestPointIndex = findClosestPoints(flatbush, aSeries.data, xScale, yScale, xZoomStart, xZoomEnd, yZoomStart, yZoomEnd, svgPoint.x, svgPoint.y, maxRadius)[0];
        if (closestPointIndex === void 0) {
          continue;
        }
        const point = aSeries.data[closestPointIndex];
        const scaledX = xScale(point.x);
        const scaledY = yScale(point.y);
        const distSq = (scaledX - svgPoint.x) ** 2 + (scaledY - svgPoint.y) ** 2;
        if (closestPoint === void 0 || distSq < closestPoint.distanceSq) {
          closestPoint = {
            dataIndex: closestPointIndex,
            seriesId,
            distanceSq: distSq
          };
        }
      }
      if (closestPoint === void 0) {
        return "no-point-found";
      }
      return {
        seriesId: closestPoint.seriesId,
        dataIndex: closestPoint.dataIndex
      };
    }
    const moveEndHandler = instance.addInteractionListener("moveEnd", (event) => {
      if (!event.detail.activeGestures.pan) {
        instance.cleanInteraction?.();
        instance.clearHighlight?.();
        instance.removeTooltipItem?.();
      }
    });
    const panEndHandler = instance.addInteractionListener("panEnd", (event) => {
      if (!event.detail.activeGestures.move) {
        instance.cleanInteraction?.();
        instance.clearHighlight?.();
        instance.removeTooltipItem?.();
      }
    });
    const pressEndHandler = instance.addInteractionListener("quickPressEnd", (event) => {
      if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
        instance.cleanInteraction?.();
        instance.clearHighlight?.();
        instance.removeTooltipItem?.();
      }
    });
    const gestureHandler = (event) => {
      const closestPoint = getClosestPoint(event.detail.srcEvent);
      if (closestPoint === "outside-chart") {
        instance.cleanInteraction?.();
        instance.clearHighlight?.();
        instance.removeTooltipItem?.();
        return;
      }
      if (closestPoint === "outside-voronoi-max-radius" || closestPoint === "no-point-found") {
        instance.removeTooltipItem?.();
        instance.clearHighlight?.();
        instance.removeTooltipItem?.();
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      instance.setTooltipItem?.({
        type: "scatter",
        seriesId,
        dataIndex
      });
      instance.setLastUpdateSource?.("pointer");
      instance.setHighlight?.({
        seriesId,
        dataIndex
      });
    };
    const tapHandler = instance.addInteractionListener("tap", (event) => {
      const closestPoint = getClosestPoint(event.detail.srcEvent);
      if (typeof closestPoint !== "string" && onItemClick) {
        const {
          seriesId,
          dataIndex
        } = closestPoint;
        onItemClick(event.detail.srcEvent, {
          type: "scatter",
          seriesId,
          dataIndex
        });
      }
    });
    const moveHandler = instance.addInteractionListener("move", gestureHandler);
    const panHandler = instance.addInteractionListener("pan", gestureHandler);
    const pressHandler = instance.addInteractionListener("quickPress", gestureHandler);
    return () => {
      tapHandler.cleanup();
      moveHandler.cleanup();
      moveEndHandler.cleanup();
      panHandler.cleanup();
      panEndHandler.cleanup();
      pressHandler.cleanup();
      pressEndHandler.cleanup();
    };
  }, [svgRef, yAxis, xAxis, voronoiMaxRadius, onItemClick, disableVoronoi, instance, seriesOrder, series, flatbushMap, defaultXAxisId, defaultYAxisId, store]);
  const enableVoronoiCallback = useEventCallback_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: true
    });
  });
  const disableVoronoiCallback = useEventCallback_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: false
    });
  });
  return {
    instance: {
      enableVoronoi: enableVoronoiCallback,
      disableVoronoi: disableVoronoiCallback
    }
  };
};
useChartClosestPoint.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  disableVoronoi: params.disableVoronoi ?? !params.series.some((item) => item.type === "scatter")
});
useChartClosestPoint.getInitialState = (params) => ({
  voronoi: {
    isVoronoiEnabled: !params.disableVoronoi
  }
});
useChartClosestPoint.params = {
  disableVoronoi: true,
  voronoiMaxRadius: true,
  onItemClick: true
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.selectors.js
var selectVoronoi = (state) => state.voronoi;
var selectorChartsIsVoronoiEnabled = createSelector(selectVoronoi, (voronoi) => voronoi?.isVoronoiEnabled);

// node_modules/@mui/x-charts/esm/internals/plugins/allPlugins.js
var DEFAULT_PLUGINS = [useChartZAxis, useChartBrush, useChartTooltip, useChartInteraction, useChartCartesianAxis, useChartHighlight, useChartClosestPoint, useChartKeyboardNavigation];

// node_modules/@mui/x-charts/esm/ChartDataProvider/useChartDataProviderProps.js
var _excluded27 = ["children", "localeText", "plugins", "seriesConfig", "slots", "slotProps"];
var useChartDataProviderProps = (inProps) => {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartDataProvider"
  });
  const {
    children,
    localeText,
    plugins = DEFAULT_PLUGINS,
    seriesConfig,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded27);
  const theme = useTheme();
  const chartProviderProps = {
    plugins,
    seriesConfig,
    pluginParams: _extends({
      theme: theme.palette.mode
    }, other)
  };
  return {
    children,
    localeText,
    chartProviderProps,
    slots,
    slotProps
  };
};

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
function ChartDataProvider(props) {
  const {
    children,
    localeText,
    chartProviderProps,
    slots,
    slotProps
  } = useChartDataProviderProps(props);
  return (0, import_jsx_runtime43.jsx)(ChartProvider, _extends({}, chartProviderProps, {
    children: (0, import_jsx_runtime43.jsx)(ChartsLocalizationProvider, {
      localeText,
      children: (0, import_jsx_runtime43.jsx)(ChartsSlotsProvider, {
        slots,
        slotProps,
        defaultSlots: defaultSlotsMaterial,
        children
      })
    })
  }));
}
true ? ChartDataProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types26.default.shape({
    current: import_prop_types26.default.any
  }),
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.string), import_prop_types26.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types26.default.arrayOf(import_prop_types26.default.object),
  /**
   * Options to enable features planned for the next major.
   */
  experimentalFeatures: import_prop_types26.default.shape({
    preferStrictDomainInLineCharts: import_prop_types26.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types26.default.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types26.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types26.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.shape({
    bottom: import_prop_types26.default.number,
    left: import_prop_types26.default.number,
    right: import_prop_types26.default.number,
    top: import_prop_types26.default.number
  })]),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types26.default.arrayOf(import_prop_types26.default.object),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types26.default.bool,
  /**
   * The props for the slots.
   */
  slotProps: import_prop_types26.default.object,
  /**
   * Slots to customize charts' components.
   */
  slots: import_prop_types26.default.object,
  theme: import_prop_types26.default.oneOf(["dark", "light"]),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types26.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartContainer/useChartContainerProps.js
var _excluded28 = ["width", "height", "margin", "children", "series", "colors", "dataset", "desc", "onAxisClick", "highlightedAxis", "onHighlightedAxisChange", "disableVoronoi", "voronoiMaxRadius", "onItemClick", "disableAxisListener", "highlightedItem", "onHighlightChange", "sx", "title", "xAxis", "yAxis", "zAxis", "rotationAxis", "radiusAxis", "skipAnimation", "seriesConfig", "plugins", "localeText", "slots", "slotProps", "experimentalFeatures", "enableKeyboardNavigation", "brushConfig"];
var useChartContainerProps = (props, ref) => {
  const _ref = props, {
    width,
    height,
    margin,
    children,
    series,
    colors,
    dataset,
    desc,
    onAxisClick,
    highlightedAxis,
    onHighlightedAxisChange,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    sx,
    title,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    seriesConfig,
    plugins,
    localeText,
    slots,
    slotProps,
    experimentalFeatures,
    enableKeyboardNavigation,
    brushConfig
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded28);
  const chartsSurfaceProps = _extends({
    title,
    desc,
    sx,
    ref
  }, other);
  const chartDataProviderProps = {
    margin,
    series,
    colors,
    dataset,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    onAxisClick,
    highlightedAxis,
    onHighlightedAxisChange,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    width,
    height,
    localeText,
    seriesConfig,
    experimentalFeatures,
    enableKeyboardNavigation,
    brushConfig,
    plugins: plugins ?? DEFAULT_PLUGINS,
    slots,
    slotProps
  };
  return {
    chartDataProviderProps,
    chartsSurfaceProps,
    children
  };
};

// node_modules/@mui/x-charts/esm/ChartsWrapper/ChartsWrapper.js
var React50 = __toESM(require_react(), 1);
var import_prop_types29 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/Toolbar/Toolbar.js
var React48 = __toESM(require_react(), 1);
var import_prop_types27 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-internals/esm/useComponentRenderer/useComponentRenderer.js
var React45 = __toESM(require_react(), 1);
function useComponentRenderer(defaultElement, render, props, state = {}) {
  if (typeof render === "function") {
    return render(props, state);
  }
  if (render) {
    if (render.props.className) {
      props.className = mergeClassNames(render.props.className, props.className);
    }
    if (render.props.style || props.style) {
      props.style = _extends({}, props.style, render.props.style);
    }
    return React45.cloneElement(render, props);
  }
  return React45.createElement(defaultElement, props);
}
function mergeClassNames(className, otherClassName) {
  if (!className || !otherClassName) {
    return className || otherClassName;
  }
  return `${className} ${otherClassName}`;
}

// node_modules/@mui/x-internals/esm/ToolbarContext/ToolbarContext.js
var React46 = __toESM(require_react(), 1);
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var ToolbarContext = React46.createContext(void 0);
if (true) ToolbarContext.displayName = "ToolbarContext";
function useToolbarContext() {
  const context = React46.useContext(ToolbarContext);
  if (context === void 0) {
    throw new Error("MUI X: Missing context. Toolbar subcomponents must be placed within a <Toolbar /> component.");
  }
  return context;
}
function ToolbarContextProvider({
  children
}) {
  const [focusableItemId, setFocusableItemId] = React46.useState(null);
  const focusableItemIdRef = React46.useRef(focusableItemId);
  const [items, setItems] = React46.useState([]);
  const getSortedItems = React46.useCallback(() => items.sort(sortByDocumentPosition), [items]);
  const findEnabledItem = React46.useCallback((startIndex, step, wrap = true) => {
    let index = startIndex;
    const sortedItems = getSortedItems();
    const itemCount = sortedItems.length;
    for (let i = 0; i < itemCount; i += 1) {
      index += step;
      if (index >= itemCount) {
        if (!wrap) {
          return -1;
        }
        index = 0;
      } else if (index < 0) {
        if (!wrap) {
          return -1;
        }
        index = itemCount - 1;
      }
      if (!sortedItems[index].ref.current?.disabled && sortedItems[index].ref.current?.ariaDisabled !== "true") {
        return index;
      }
    }
    return -1;
  }, [getSortedItems]);
  const registerItem = React46.useCallback((id, itemRef) => {
    setItems((prevItems) => [...prevItems, {
      id,
      ref: itemRef
    }]);
  }, []);
  const unregisterItem = React46.useCallback((id) => {
    setItems((prevItems) => prevItems.filter((i) => i.id !== id));
  }, []);
  const onItemKeyDown = React46.useCallback((event) => {
    if (!focusableItemId) {
      return;
    }
    const sortedItems = getSortedItems();
    const focusableItemIndex = sortedItems.findIndex((item) => item.id === focusableItemId);
    let newIndex = -1;
    if (event.key === "ArrowRight") {
      event.preventDefault();
      newIndex = findEnabledItem(focusableItemIndex, 1);
    } else if (event.key === "ArrowLeft") {
      event.preventDefault();
      newIndex = findEnabledItem(focusableItemIndex, -1);
    } else if (event.key === "Home") {
      event.preventDefault();
      newIndex = findEnabledItem(-1, 1, false);
    } else if (event.key === "End") {
      event.preventDefault();
      newIndex = findEnabledItem(sortedItems.length, -1, false);
    }
    if (newIndex >= 0 && newIndex < sortedItems.length) {
      const item = sortedItems[newIndex];
      setFocusableItemId(item.id);
      item.ref.current?.focus();
    }
  }, [getSortedItems, focusableItemId, findEnabledItem]);
  const onItemFocus = React46.useCallback((id) => {
    if (focusableItemId !== id) {
      setFocusableItemId(id);
    }
  }, [focusableItemId, setFocusableItemId]);
  const onItemDisabled = React46.useCallback((id) => {
    const sortedItems = getSortedItems();
    const currentIndex = sortedItems.findIndex((item) => item.id === id);
    const newIndex = findEnabledItem(currentIndex, 1);
    if (newIndex >= 0 && newIndex < sortedItems.length) {
      const item = sortedItems[newIndex];
      setFocusableItemId(item.id);
      item.ref.current?.focus();
    }
  }, [getSortedItems, findEnabledItem]);
  React46.useEffect(() => {
    focusableItemIdRef.current = focusableItemId;
  }, [focusableItemId]);
  React46.useEffect(() => {
    const sortedItems = getSortedItems();
    if (sortedItems.length > 0) {
      if (!focusableItemIdRef.current) {
        setFocusableItemId(sortedItems[0].id);
        return;
      }
      const focusableItemIndex = sortedItems.findIndex((item) => item.id === focusableItemIdRef.current);
      if (!sortedItems[focusableItemIndex]) {
        const item = sortedItems[sortedItems.length - 1];
        if (item) {
          setFocusableItemId(item.id);
          item.ref.current?.focus();
        }
      } else if (focusableItemIndex === -1) {
        const item = sortedItems[focusableItemIndex];
        if (item) {
          setFocusableItemId(item.id);
          item.ref.current?.focus();
        }
      }
    }
  }, [getSortedItems, findEnabledItem]);
  const contextValue = React46.useMemo(() => ({
    focusableItemId,
    registerItem,
    unregisterItem,
    onItemKeyDown,
    onItemFocus,
    onItemDisabled
  }), [focusableItemId, registerItem, unregisterItem, onItemKeyDown, onItemFocus, onItemDisabled]);
  return (0, import_jsx_runtime44.jsx)(ToolbarContext.Provider, {
    value: contextValue,
    children
  });
}
function sortByDocumentPosition(a, b) {
  if (!a.ref.current || !b.ref.current) {
    return 0;
  }
  const position = a.ref.current.compareDocumentPosition(b.ref.current);
  if (!position) {
    return 0;
  }
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}

// node_modules/@mui/x-internals/esm/ToolbarContext/useRegisterToolbarButton.js
var React47 = __toESM(require_react(), 1);
function useRegisterToolbarButton(props, ref) {
  const {
    onKeyDown,
    onFocus,
    disabled,
    "aria-disabled": ariaDisabled
  } = props;
  const id = useId();
  const {
    focusableItemId,
    registerItem,
    unregisterItem,
    onItemKeyDown,
    onItemFocus,
    onItemDisabled
  } = useToolbarContext();
  const handleKeyDown = (event) => {
    onItemKeyDown(event);
    onKeyDown?.(event);
  };
  const handleFocus = (event) => {
    onItemFocus(id);
    onFocus?.(event);
  };
  React47.useEffect(() => {
    registerItem(id, ref);
    return () => unregisterItem(id);
  }, [id, ref, registerItem, unregisterItem]);
  const previousDisabled = React47.useRef(disabled);
  React47.useEffect(() => {
    if (previousDisabled.current !== disabled && disabled === true) {
      onItemDisabled(id, disabled);
    }
    previousDisabled.current = disabled;
  }, [disabled, id, onItemDisabled]);
  const previousAriaDisabled = React47.useRef(ariaDisabled);
  React47.useEffect(() => {
    if (previousAriaDisabled.current !== ariaDisabled && ariaDisabled === true) {
      onItemDisabled(id, true);
    }
    previousAriaDisabled.current = ariaDisabled;
  }, [ariaDisabled, id, onItemDisabled]);
  return {
    tabIndex: focusableItemId === id ? 0 : -1,
    disabled,
    "aria-disabled": ariaDisabled,
    onKeyDown: handleKeyDown,
    onFocus: handleFocus
  };
}

// node_modules/@mui/x-charts/esm/Toolbar/chartToolbarClasses.js
var chartsToolbarClasses = generateUtilityClasses("MuiChartsToolbar", ["root"]);

// node_modules/@mui/x-charts/esm/Toolbar/Toolbar.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var _excluded29 = ["className", "render"];
var ToolbarRoot = styled_default("div", {
  name: "MuiChartsToolbar",
  slot: "Root"
})(({
  theme
}) => ({
  flex: 0,
  display: "flex",
  alignItems: "center",
  justifyContent: "end",
  gap: theme.spacing(0.25),
  padding: theme.spacing(0.5),
  marginBottom: theme.spacing(1.5),
  minHeight: 44,
  boxSizing: "border-box",
  border: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderRadius: 4
}));
var Toolbar = React48.forwardRef(function Toolbar2(_ref, ref) {
  let {
    className,
    render
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded29);
  const element = useComponentRenderer(ToolbarRoot, render, _extends({
    role: "toolbar",
    "aria-orientation": "horizontal",
    className: clsx_default(chartsToolbarClasses.root, className)
  }, other, {
    ref
  }));
  return (0, import_jsx_runtime45.jsx)(ToolbarContextProvider, {
    children: element
  });
});
if (true) Toolbar.displayName = "Toolbar";
true ? Toolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  className: import_prop_types27.default.string,
  /**
   * A function to customize rendering of the component.
   */
  render: import_prop_types27.default.oneOfType([import_prop_types27.default.element, import_prop_types27.default.func])
} : void 0;

// node_modules/@mui/x-charts/esm/Toolbar/ToolbarButton.js
var import_prop_types28 = __toESM(require_prop_types(), 1);
var React49 = __toESM(require_react(), 1);
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var _excluded30 = ["render", "onKeyDown", "onFocus", "disabled", "aria-disabled"];
var _excluded210 = ["tabIndex"];
var ToolbarButton = React49.forwardRef(function ToolbarButton2(props, ref) {
  const {
    render
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded30);
  const {
    slots,
    slotProps
  } = useChartsSlots();
  const buttonRef = React49.useRef(null);
  const handleRef = useForkRef(buttonRef, ref);
  const _useRegisterToolbarBu = useRegisterToolbarButton(props, buttonRef), {
    tabIndex
  } = _useRegisterToolbarBu, toolbarButtonProps = _objectWithoutPropertiesLoose(_useRegisterToolbarBu, _excluded210);
  const element = useComponentRenderer(slots.baseIconButton, render, _extends({}, slotProps?.baseIconButton, {
    tabIndex
  }, other, toolbarButtonProps, {
    ref: handleRef
  }));
  return (0, import_jsx_runtime46.jsx)(React49.Fragment, {
    children: element
  });
});
if (true) ToolbarButton.displayName = "ToolbarButton";
true ? ToolbarButton.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  className: import_prop_types28.default.string,
  disabled: import_prop_types28.default.bool,
  id: import_prop_types28.default.string,
  /**
   * A function to customize the rendering of the component.
   */
  render: import_prop_types28.default.oneOfType([import_prop_types28.default.element, import_prop_types28.default.func]),
  size: import_prop_types28.default.oneOf(["large", "medium", "small"]),
  style: import_prop_types28.default.object,
  tabIndex: import_prop_types28.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsWrapper/ChartsWrapper.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var getJustifyItems = (position) => {
  if (position?.horizontal === "start") {
    return "start";
  }
  if (position?.horizontal === "end") {
    return "end";
  }
  return "center";
};
var getAlignItems = (position) => {
  if (position?.vertical === "top") {
    return "flex-start";
  }
  if (position?.vertical === "bottom") {
    return "flex-end";
  }
  return "center";
};
var getGridTemplateAreas = (hideLegend, direction, position) => {
  if (hideLegend) {
    return `"chart"`;
  }
  if (direction === "vertical") {
    if (position?.horizontal === "start") {
      return `"legend chart"`;
    }
    return `"chart legend"`;
  }
  if (position?.vertical === "bottom") {
    return `"chart"
            "legend"`;
  }
  return `"legend"
          "chart"`;
};
var getTemplateColumns = (hideLegend = false, direction = "horizontal", horizontalPosition = "end", width = void 0) => {
  const drawingAreaColumn = width ? "auto" : "1fr";
  if (direction === "horizontal") {
    return drawingAreaColumn;
  }
  if (hideLegend) {
    return drawingAreaColumn;
  }
  return horizontalPosition === "start" ? `auto ${drawingAreaColumn}` : `${drawingAreaColumn} auto`;
};
var getTemplateRows = (hideLegend = false, direction = "horizontal", verticalPosition = "top") => {
  const drawingAreaRow = "1fr";
  if (direction === "vertical") {
    return drawingAreaRow;
  }
  if (hideLegend) {
    return drawingAreaRow;
  }
  return verticalPosition === "bottom" ? `${drawingAreaRow} auto` : `auto ${drawingAreaRow}`;
};
var Root3 = styled_default("div", {
  name: "MuiChartsWrapper",
  slot: "Root",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "extendVertically" && prop !== "width"
})(({
  ownerState,
  width
}) => {
  const gridTemplateColumns = getTemplateColumns(ownerState.hideLegend, ownerState.legendDirection, ownerState.legendPosition?.horizontal, width);
  const gridTemplateRows = getTemplateRows(ownerState.hideLegend, ownerState.legendDirection, ownerState.legendPosition?.vertical);
  const gridTemplateAreas = getGridTemplateAreas(ownerState.hideLegend, ownerState.legendDirection, ownerState.legendPosition);
  return {
    variants: [{
      props: {
        extendVertically: true
      },
      style: {
        height: "100%",
        minHeight: 0
      }
    }],
    flex: 1,
    display: "grid",
    gridTemplateColumns,
    gridTemplateRows,
    gridTemplateAreas,
    [`&:has(.${chartsToolbarClasses.root})`]: {
      // Add a row for toolbar if there is one.
      gridTemplateRows: `auto ${gridTemplateRows}`,
      gridTemplateAreas: `"${gridTemplateColumns.split(" ").map(() => "toolbar").join(" ")}"
        ${gridTemplateAreas}`
    },
    [`& .${chartsToolbarClasses.root}`]: {
      gridArea: "toolbar",
      justifySelf: "center"
    },
    justifyContent: "safe center",
    justifyItems: getJustifyItems(ownerState.legendPosition),
    alignItems: getAlignItems(ownerState.legendPosition)
  };
});
function ChartsWrapper(props) {
  const {
    children,
    sx,
    extendVertically
  } = props;
  const chartRootRef = useChartRootRef();
  const store = useStore();
  const propsWidth = store.use(selectorChartPropsWidth);
  const propsHeight = store.use(selectorChartPropsHeight);
  return (0, import_jsx_runtime47.jsx)(Root3, {
    ref: chartRootRef,
    ownerState: props,
    sx,
    extendVertically: extendVertically ?? propsHeight === void 0,
    width: propsWidth,
    children
  });
}
true ? ChartsWrapper.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types29.default.node,
  /**
   * If `true`, the chart wrapper set `height: 100%`.
   * @default `false` if the `height` prop is set. And `true` otherwise.
   */
  extendVertically: import_prop_types29.default.bool,
  /**
   * If `true`, the legend is not rendered.
   * @default false
   */
  hideLegend: import_prop_types29.default.bool,
  /**
   * The direction of the legend.
   * @default 'horizontal'
   */
  legendDirection: import_prop_types29.default.oneOf(["horizontal", "vertical"]),
  /**
   * The position of the legend.
   * @default { horizontal: 'center', vertical: 'bottom' }
   */
  legendPosition: import_prop_types29.default.shape({
    horizontal: import_prop_types29.default.oneOf(["center", "end", "start"]),
    vertical: import_prop_types29.default.oneOf(["bottom", "middle", "top"])
  }),
  sx: import_prop_types29.default.oneOfType([import_prop_types29.default.arrayOf(import_prop_types29.default.oneOfType([import_prop_types29.default.func, import_prop_types29.default.object, import_prop_types29.default.bool])), import_prop_types29.default.func, import_prop_types29.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/FocusedBar.js
var React51 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/hooks/useFocusedItem.js
function useFocusedItem() {
  const store = useStore();
  return store.use(selectorChartsFocusedItem);
}

// node_modules/@mui/x-charts/esm/BarChart/FocusedBar.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function FocusedBar(props) {
  const theme = useTheme();
  const focusedItem = useFocusedItem();
  const barSeries = useBarSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  if (focusedItem === null || focusedItem.type !== "bar" || !barSeries) {
    return null;
  }
  const series = barSeries?.series[focusedItem.seriesId];
  const xAxisId = series.xAxisId ?? xAxisIds[0];
  const yAxisId = series.yAxisId ?? yAxisIds[0];
  const xAxisConfig = xAxis[xAxisId];
  const yAxisConfig = yAxis[yAxisId];
  const verticalLayout = barSeries.series[focusedItem.seriesId].layout === "vertical";
  const groupIndex = barSeries.stackingGroups.findIndex((group) => group.ids.includes(focusedItem.seriesId));
  const barDimensions = getBarDimensions({
    verticalLayout,
    xAxisConfig,
    yAxisConfig,
    series,
    dataIndex: focusedItem.dataIndex,
    numberOfGroups: barSeries.stackingGroups.length,
    groupIndex
  });
  if (barDimensions === null) {
    return null;
  }
  const {
    x,
    y,
    height,
    width
  } = barDimensions;
  return (0, import_jsx_runtime48.jsx)("rect", _extends({
    fill: "none",
    stroke: (theme.vars ?? theme).palette.text.primary,
    strokeWidth: 2,
    x: x - 3,
    y: y - 3,
    width: width + 6,
    height: height + 6,
    rx: 3,
    ry: 3
  }, props));
}

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var BarChart = React52.forwardRef(function BarChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarChart"
  });
  const {
    chartsWrapperProps,
    chartContainerProps,
    barPlotProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    children
  } = useBarChartProps(props);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(chartContainerProps, ref);
  const Tooltip = props.slots?.tooltip ?? ChartsTooltip;
  const Toolbar3 = props.slots?.toolbar;
  return (0, import_jsx_runtime49.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime49.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [props.showToolbar && Toolbar3 ? (0, import_jsx_runtime49.jsx)(Toolbar3, _extends({}, props.slotProps?.toolbar)) : null, !props.hideLegend && (0, import_jsx_runtime49.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime49.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime49.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime49.jsxs)("g", _extends({}, clipPathGroupProps, {
          children: [(0, import_jsx_runtime49.jsx)(BarPlot, _extends({}, barPlotProps)), (0, import_jsx_runtime49.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime49.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps)), (0, import_jsx_runtime49.jsx)(FocusedBar, {})]
        })), (0, import_jsx_runtime49.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime49.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
      })), !props.loading && (0, import_jsx_runtime49.jsx)(Tooltip, _extends({}, props.slotProps?.tooltip))]
    }))
  }));
});
if (true) BarChart.displayName = "BarChart";
true ? BarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types30.default.shape({
    current: import_prop_types30.default.object
  }),
  /**
   * The configuration of axes highlight.
   * Default is set to 'band' in the bar direction.
   * Depends on `layout` prop.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   */
  axisHighlight: import_prop_types30.default.shape({
    x: import_prop_types30.default.oneOf(["band", "line", "none"]),
    y: import_prop_types30.default.oneOf(["band", "line", "none"])
  }),
  /**
   * @deprecated Use `barLabel` in the chart series instead.
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["value"]), import_prop_types30.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types30.default.number,
  /**
   * Configuration for the brush interaction.
   */
  brushConfig: import_prop_types30.default.shape({
    enabled: import_prop_types30.default.bool,
    preventHighlight: import_prop_types30.default.bool,
    preventTooltip: import_prop_types30.default.bool
  }),
  children: import_prop_types30.default.node,
  className: import_prop_types30.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string), import_prop_types30.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types30.default.arrayOf(import_prop_types30.default.object),
  desc: import_prop_types30.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types30.default.bool,
  enableKeyboardNavigation: import_prop_types30.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types30.default.shape({
    horizontal: import_prop_types30.default.bool,
    vertical: import_prop_types30.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types30.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types30.default.bool,
  /**
   * The controlled axis highlight.
   * Identified by the axis id, and data index.
   */
  highlightedAxis: import_prop_types30.default.arrayOf(import_prop_types30.default.shape({
    axisId: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]).isRequired,
    dataIndex: import_prop_types30.default.number.isRequired
  })),
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types30.default.shape({
    dataIndex: import_prop_types30.default.number,
    seriesId: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types30.default.string,
  /**
   * The direction of the bar elements.
   * @default 'vertical'
   */
  layout: import_prop_types30.default.oneOf(["horizontal", "vertical"]),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types30.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types30.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
    bottom: import_prop_types30.default.number,
    left: import_prop_types30.default.number,
    right: import_prop_types30.default.number,
    top: import_prop_types30.default.number
  })]),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types30.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types30.default.func,
  /**
   * The function called when the pointer position corresponds to a new axis data item.
   * This update can either be caused by a pointer movement, or an axis update.
   * In case of multiple axes, the function is called if at least one axis is updated.
   * The argument contains the identifier for all axes with a `data` property.
   * @param {AxisItemIdentifier[]} axisItems The array of axes item identifiers.
   */
  onHighlightedAxisChange: import_prop_types30.default.func,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types30.default.func,
  /**
   * The series to display in the bar chart.
   * An array of [[BarSeries]] objects.
   */
  series: import_prop_types30.default.arrayOf(import_prop_types30.default.object).isRequired,
  /**
   * If true, shows the default chart toolbar.
   * @default false
   */
  showToolbar: import_prop_types30.default.bool,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types30.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types30.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types30.default.object,
  sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
  theme: import_prop_types30.default.oneOf(["dark", "light"]),
  title: import_prop_types30.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types30.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    barGapRatio: import_prop_types30.default.number,
    categoryGapRatio: import_prop_types30.default.number,
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      type: import_prop_types30.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types30.default.string,
      values: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number, import_prop_types30.default.string]).isRequired)
    }), import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    groups: import_prop_types30.default.arrayOf(import_prop_types30.default.shape({
      getValue: import_prop_types30.default.func.isRequired,
      tickLabelStyle: import_prop_types30.default.object,
      tickSize: import_prop_types30.default.number
    })),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    offset: import_prop_types30.default.number,
    ordinalTimeTicks: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["biweekly", "days", "hours", "months", "quarterly", "weeks", "years"]), import_prop_types30.default.shape({
      format: import_prop_types30.default.func.isRequired,
      getTickNumber: import_prop_types30.default.func.isRequired,
      isTick: import_prop_types30.default.func.isRequired
    })]).isRequired),
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["band"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      type: import_prop_types30.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types30.default.string,
      values: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number, import_prop_types30.default.string]).isRequired)
    }), import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    groups: import_prop_types30.default.arrayOf(import_prop_types30.default.shape({
      getValue: import_prop_types30.default.func.isRequired,
      tickLabelStyle: import_prop_types30.default.object,
      tickSize: import_prop_types30.default.number
    })),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    offset: import_prop_types30.default.number,
    ordinalTimeTicks: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["biweekly", "days", "hours", "months", "quarterly", "weeks", "years"]), import_prop_types30.default.shape({
      format: import_prop_types30.default.func.isRequired,
      getTickNumber: import_prop_types30.default.func.isRequired,
      isTick: import_prop_types30.default.func.isRequired
    })]).isRequired),
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["point"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["log"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    constant: import_prop_types30.default.number,
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["symlog"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["pow"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["sqrt"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    min: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["time"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    min: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["utc"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["x"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    height: import_prop_types30.default.number,
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["linear"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelMinGap: import_prop_types30.default.number,
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    barGapRatio: import_prop_types30.default.number,
    categoryGapRatio: import_prop_types30.default.number,
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      type: import_prop_types30.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types30.default.string,
      values: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number, import_prop_types30.default.string]).isRequired)
    }), import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    groups: import_prop_types30.default.arrayOf(import_prop_types30.default.shape({
      getValue: import_prop_types30.default.func.isRequired,
      tickLabelStyle: import_prop_types30.default.object,
      tickSize: import_prop_types30.default.number
    })),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    offset: import_prop_types30.default.number,
    ordinalTimeTicks: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["biweekly", "days", "hours", "months", "quarterly", "weeks", "years"]), import_prop_types30.default.shape({
      format: import_prop_types30.default.func.isRequired,
      getTickNumber: import_prop_types30.default.func.isRequired,
      isTick: import_prop_types30.default.func.isRequired
    })]).isRequired),
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["band"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      type: import_prop_types30.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types30.default.string,
      values: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number, import_prop_types30.default.string]).isRequired)
    }), import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    groups: import_prop_types30.default.arrayOf(import_prop_types30.default.shape({
      getValue: import_prop_types30.default.func.isRequired,
      tickLabelStyle: import_prop_types30.default.object,
      tickSize: import_prop_types30.default.number
    })),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    offset: import_prop_types30.default.number,
    ordinalTimeTicks: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["biweekly", "days", "hours", "months", "quarterly", "weeks", "years"]), import_prop_types30.default.shape({
      format: import_prop_types30.default.func.isRequired,
      getTickNumber: import_prop_types30.default.func.isRequired,
      isTick: import_prop_types30.default.func.isRequired
    })]).isRequired),
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["point"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["log"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    constant: import_prop_types30.default.number,
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["symlog"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["pow"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["sqrt"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    min: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["time"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    min: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.shape({
      valueOf: import_prop_types30.default.func.isRequired
    })]),
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["utc"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  }), import_prop_types30.default.shape({
    axis: import_prop_types30.default.oneOf(["y"]),
    classes: import_prop_types30.default.object,
    colorMap: import_prop_types30.default.oneOfType([import_prop_types30.default.shape({
      color: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.string.isRequired), import_prop_types30.default.func]).isRequired,
      max: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      min: import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]),
      type: import_prop_types30.default.oneOf(["continuous"]).isRequired
    }), import_prop_types30.default.shape({
      colors: import_prop_types30.default.arrayOf(import_prop_types30.default.string).isRequired,
      thresholds: import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.instanceOf(Date), import_prop_types30.default.number]).isRequired).isRequired,
      type: import_prop_types30.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types30.default.array,
    dataKey: import_prop_types30.default.string,
    disableLine: import_prop_types30.default.bool,
    disableTicks: import_prop_types30.default.bool,
    domainLimit: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["nice", "strict"]), import_prop_types30.default.func]),
    hideTooltip: import_prop_types30.default.bool,
    id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
    ignoreTooltip: import_prop_types30.default.bool,
    label: import_prop_types30.default.string,
    labelStyle: import_prop_types30.default.object,
    max: import_prop_types30.default.number,
    min: import_prop_types30.default.number,
    offset: import_prop_types30.default.number,
    position: import_prop_types30.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types30.default.bool,
    scaleType: import_prop_types30.default.oneOf(["linear"]),
    slotProps: import_prop_types30.default.object,
    slots: import_prop_types30.default.object,
    sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
    tickInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.array, import_prop_types30.default.func]),
    tickLabelInterval: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["auto"]), import_prop_types30.default.func]),
    tickLabelPlacement: import_prop_types30.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types30.default.object,
    tickMaxStep: import_prop_types30.default.number,
    tickMinStep: import_prop_types30.default.number,
    tickNumber: import_prop_types30.default.number,
    tickPlacement: import_prop_types30.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types30.default.number,
    tickSpacing: import_prop_types30.default.number,
    valueFormatter: import_prop_types30.default.func,
    width: import_prop_types30.default.number
  })]).isRequired)
} : void 0;
export {
  BAR_CHART_PLUGINS,
  BarChart,
  BarElement,
  BarLabel,
  BarPlot,
  FocusedBar,
  barClasses,
  barElementClasses,
  barLabelClasses,
  getBarElementUtilityClass,
  getBarLabelUtilityClass,
  getBarUtilityClass,
  useUtilityClasses
};
//# sourceMappingURL=@mui_x-charts_BarChart.js.map
